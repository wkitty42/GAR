#!/usr/bin/perl
# Guardian Active Response - Smoothwall Express IP Blocker for Snort Alerts
#
my ${appIDextra} = 'b1';    # application release level
my ${partial_secs} = 100;   # how many parts to divide a second into
my ${loop_secs} = .5;       # how many seconds between housework chores
#
# This version is an extensive rewrite and reorganization based on v1.85.
# This is being done specifically for Smoothwall3 by wkitty42. Thanks to
# s-t-p for porting NetWhiz's SWE2 version to SWE3 and to NetWhiz for doing
# the work to make this available and operational on SW machines. Some code
# has stayed the same. Numerous new routines have been added. Some existing
# code has been split into seperate routines. A lot of code has been
# massaged a bit for compatibility with the new features and abilities. And
# finally, some code has simply been removed. The biggest change is the use
# of ipset sets to store the blocked IPs in.
#
#  * LogMsgLevel config verb - new logging format with selectable detail level 0-9.
#    recommended at least level 3 or 4 for normal operation.
#      0 - " " - Standard Operation Messages
#      1 - "!" - Fatal Errors
#      2 - "?" - Other Errors
#      3 - "*" - Brief Messages
#      4 - "+" - Trivial Messages
#      5 - "-" - Mundane Messages
#      6 - "$" - No Action Taken Messages
#      7 - "#" - Configuration Information
#      8 - ":" - Each line processed from snort alert file
#      9 - "%" - debug - Entry/Exit checkem and ipchain routines

use lib "/usr/lib/smoothwall";
use header qw( :standard );
use Getopt::Std;

require Time::HiRes;
require Net::CIDR;

getopts ('hc:kv');

my @msgsymbols = (" ","!","\?","*","+","-","\$","#",":","\%");
my ${GAR_Root_dir} = "/mods/GAR";
my ${GAR_Home_dir} = "${swroot}"."${GAR_Root_dir}";
my ${GAR_Logo} = "${GAR_Root_dir}/ui/img/alligator-gar-50-2.png";
my ${GARiptracker_dir} = "${GAR_Home_dir}/var/db";           # the source IP must be appended to this for tracking
#my ${GARversion_filename} = "${GAR_Home_dir}/installed";
my ${GARdetails_filename} = "${GAR_Home_dir}/DETAILS";
my ${GARipblock_filename} = "${GARiptracker_dir}/GARipblock";
my ${defaultlog_filename} = "${GAR_Home_dir}/var/log/GAR.log";
my ${GARipunblock_filename} = "${GARiptracker_dir}/unblock";
my ${defaultalert_filename} = "/var/log/snort/alert";
my ${defaultconfig_filename} = "${GAR_Home_dir}/etc/GAR.conf";
my ${GARsaved_ipblock_filename} = "${GARiptracker_dir}/saved";
my %SWEprodvals;
&readhash("${swroot}/main/productdata",\%SWEprodvals);
my %MODdetails;
&readhash("${GARdetails_filename}",\%MODdetails);


#open (GARVERFILE, "${GARversion_filename}") or die ("GARVERFILE: Unable to open ${GARversion_filename} for reading.");
#my ${GARprogname} = <GARVERFILE>;
#close (GARVERFILE);
#chomp ${GARprogname};
#(${GARprogname},${GARversion}) = split(/ /,${GARprogname});

${GARprogname} = $MODdetails{'MOD_NAME'};
${GARversion} = $MODdetails{'MOD_VERSION'};

my ${GARpid_filename} = "/var/run/${GARprogname}.pid";
my ${appID} = "${GARprogname} ${GARversion}-SWE$SWEprodvals{'VERSION'}-$SWEprodvals{'ARCH'}";
if (defined ${appIDextra}) {
  ${appID} = "${appID}-${appIDextra}";
}

my ${iptables_up} = "no";
# Make sure ip_block_file_name exists on startup
if ( ! -e ${GARipblock_filename} ) {
  system ('/bin/touch', "${GARipblock_filename}");
  system ('/bin/chown', "nobody:nobody", "${GARipblock_filename}");
}
# Init ip_unblock_file_name on startup
if ( ! -e ${GARipunblock_filename} ) {
  system ('/bin/touch', "${GARipunblock_filename}");
  system ('/bin/chown', "nobody:nobody", "${GARipunblock_filename}");
}
if (defined ${opt_h}) {
	print "${appID}\n";
	print "$0 [-hkv]||[-c config]||[-a xxx.xxx.xxx.xxx]||[-d xxx.xxx.xxx.xxx]||[-i xxx.xxx.xxx.xxx]||[-t xxx.xxx.xxx.xxx]\n";
	print " -h  show this help and exit\n";
	print " -v  display GAR version and exit\n";
	print " -k  terminate currently running GAR\n";
	print " -c  specifiy a configuration file other than the default\n";
#	print " -a  add IP xxx.xxx.xxx.xxx to GAR's managed block list";
#	print " -d  delete IP xxx.xxx.xxx.xxx from GAR's managed block list";
#	print " -i  add IP xxx.xxx.xxx.xxx to GAR's ignore list";
#	print " -t  add IP xxx.xxx.xxx.xxx to GAR's target list";
	exit;
}

if (defined ${opt_v}) {
	print "${appID}\n";
	exit;
}

if (defined ${opt_k}) {
	if (! -e ${GARpid_filename}) {
    die ("OPT_K: PID file, ${GARpid_filename}, not found. GAR is not running.");
  }
	open (GPID, "${GARpid_filename}") or die ("OPT_K: Cannot read pid file ${GARpid_filename}");
	my ${pid} = <GPID>;
	close (GPID);
	chomp ${pid};
	print "Sending termination signal to ${pid}.\n";
	system ('/usr/bin/kill', "${pid}");
	exit;
}

if ( -e ${GARpid_filename}) {
  die ("PID file, ${GARpid_filename}, found. ${GARprogname} is already running.");
}

&sig_handler_setup;
&load_config;
&load_saved;
&daemonize;

open (ALERT, ${alert_file}) or die ("Can't open alert file: ${alert_file}: $!");
seek (ALERT, 0, 2); # set the position to EOF, this is the same as a tail -f :)

my ${counter} = 0;
# actual partial seconds value
my ${sleep_timer} = 1 / ${partial_secs};
# times thru the loop to equal ${loop_secs} seconds
my ${loop_timer} = ${loop_secs} / ${sleep_timer};
# main processing loop
for (;;) {
  # sleep for ${sleep_timer} parts of a second
	Time::HiRes::sleep (${sleep_timer});
	if (seek (ALERT,0,1)) {
		while (<ALERT>) {
			chomp;
			&write_log (8,$_);
			# we're working with a snort.alert type file (for backwards compatibility??)
			if (/\[\*\*\]\s+(.*)\s+\[\*\*\]/){
				${type} = $1;
				&write_log (9,"found type: ${type}");
			}
			if (${type} =~ /^\[([0-9:]+)\]\s+/){ ${id} = $1; }
			if (/\[Priority: (\d+)\]/i) {
				${priority} = $1;
				&write_log (9,"found priority: ${priority}");
			}
			if (/(\d+\.\d+\.\d+\.\d+):?\d* -\> (\d+\.\d+\.\d+\.\d+):?\d*/) {
				${src_ip} = $1;
				${dst_ip} = $2;
				if (${dst_ip} eq "") { ${dst_ip} = 0; }
				&write_log (9,"found src and dst: ${src_ip} -\> ${dst_ip}");
				&checkem (${src_ip}, ${dst_ip}, ${type}, ${id}, ${priority});  # src and dst addrs are the last things we need to call checkem
				&write_log (9,"returned from checkem");
				${priority} = ''; # make sure priority is empty for next loop otherwise prev pri is still in place on empty pri alerts
			}
		}
	}
	if (${counter} == ${loop_timer}) {              # We do these chores every ${loop_secs} seconds (eg: 5 seconds / .0625 = 80 loop traversals)
		&expire_blocks;                               # remove blocked entries if they are expired
		&check_unblockfile;                           # check if there are any entries to unblock from the GUI
		&check_file_changed (${alert_file});          # check if the alert file has been rotated under us
		&check_file_changed (${opt_c});               # check if the config file has been modified under us
		&check_file_changed (${GARipblock_filename}); # check if the ipblock file has been modified under us
		if (defined ${GARignore_file}) {
			&check_file_changed (${GARignore_file});    # check if the ignore file has been modified under us
		}
		if (defined ${GARtarget_file}) {
			&check_file_changed (${GARtarget_file});    # check if the target file has been modified under us
		}
		&check_hostIP;                             # check if our WAN IP has changed
		${counter} = 0;
	} else {
		${counter}++;
	}
}

sub build_ignore_hash {
	my ${tmsg} = $_[0];
	&write_log (3,${tmsg});
	# This would cause us to ignore all broadcasts if it got set.
	# However if unset, then the attacker could spoof the packet to make
	# it look like it came from the network, and a reply to the spoofed packet
	# could be seen if the attacker were on the local network.
	# $ignore_hash{${network_address}} = 1;

	# same thing as above, just with the broadcast instead of the network.
	# $ignore_hash{${broadcast_address}} = 1;

	my ${hash_counter} = 0;
	my ${array_counter} = 0;
	if (defined ${gateway_address}) {
		$ignore_hash{${gateway_address}} = 1;
	}
	$ignore_hash{${host_ip_address}} = 1;
	@ignore_array = ();

	if ((${GARignore_file} ne "") && ( -e ${GARignore_file})) {
		open (IGNORE, "${GARignore_file}");
		while (<IGNORE>) {
			chomp;
			next if (/\#/);  #skip comments
			next if (/^\s*$/); # and blank lines
			if (/\//) {
				push(@ignore_array,$_);
				${array_counter}++;
			} else {
				$ignore_hash{$_} = 1;
				${hash_counter}++;
			}
		}
		close (IGNORE);
		&write_log (4,"Loaded ${hash_counter} addresses from ${GARignore_file}.");
		&write_log (4,"Loaded ${array_counter} CIDR netblocks from ${GARignore_file}.");
	}
}

sub build_target_hash {
	my ${tmsg} = $_[0];
	&write_log (3,${tmsg});
	# This is the target hash. If a packet was destined to any of these, then the
	# sender of that packet will get denied, unless it is on the ignore list.
	%target_hash = ("${network_address}" => 1,
		    "${broadcast_address}" => 1,
		    "0" => 1,   # This is what gets sent to &checkem if no destination was found.
		    "${host_ip_address}" => 1);
	my ${counter} = 0;
	if ((${GARtarget_file} ne "") && ( -e ${GARtarget_file})) {
		open (TARG, "${GARtarget_file}");
		while (<TARG>) {
			chomp;
			next if (/\#/);  #skip comments
			next if (/^\s*$/); # and blank lines
			$target_hash{$_} = 1;
			${counter}++;
		}
		close (TARG);
		&write_log (4,"Loaded ${counter} addresses from ${GARtarget_file}.");
	}
}

sub build_manual_hashes {
	my ${tmsg} = $_[0];
	&write_log (3,${tmsg});
	@CIDR_array = ();
	%ipblock_hash = ();
	# we're scanning the ipblock config file for IPs and CIDR netblocks entered manually.
	# the purpose of these hashes is to be able to check if an attacking IP is manually
	# managed or if it is contained within a manually managed CIDR netblock. this tracking
	# is so that we do NOT create a "Blocked by Guardian" entry for the attacking IP 
	# since it is already manually blocked.
	my ${CIDR_counter} = 0;
	my ${IP_counter} = 0;
	if ((${GARipblock_filename} ne "") && ( -e ${GARipblock_filename})) {
		open (BLOCKFILE, "${GARipblock_filename}");
		while (<BLOCKFILE>) {
			chomp;
			my @temp = split(/\,/);
			if ($temp[5] eq 'off') {        # if the entry is NOT managed by GAR
				if ($temp[0] =~/\//) {        # if the source address contains a / (ie: 1.1.1.1/24)
					push(@CIDR_array,$temp[0]);
					${CIDR_counter}++;
				} else {
					$ipblock_hash{$temp[0]} = 1;
					${IP_counter}++;
				}
			}
		}
		close (BLOCKFILE);
		&write_log (4,"Loaded ${IP_counter} manually entered IPs from ${GARipblock_filename}.");
		&write_log (4,"Loaded ${CIDR_counter} manually entered CIDR netblocks from ${GARipblock_filename}.");
	}
	(${dev},${ino},${mode},${nlink},${uid},${gid},${rdev},${size},${atime},${mtime},${ctime},${blksize},${blocks}) = stat(${GARipblock_filename});
	${prev_ipblock_ctime} = ${ctime};
}

sub check_hostIP {
	my ${oldIP} = ${host_ip_address};
	my ${newIP} = &get_host_ip(${interface});
	if (${oldIP} ne ${newIP}) {
		&write_log (3,"Our IP address has changed. Updating to new IP.");
		${host_ip_address} = ${newIP};
		&write_log (0,"IP ${host_ip_address} assigned on ${interface}.");
		&build_target_hash ("Rebuilding target hash...");    # rebuild target hash to include our new ip address
	}
}

sub check_unblockfile {
	if ( -s ${GARipunblock_filename} ) {   # The size is greater than 0, so pull out IP's and clear file
		# Open file for reading, lock it, read in contents into array, close file
		open (UNBLOCK, "${GARipunblock_filename}") or die ("CHECK_UNBLOCKFILE: Unable to open ${GARipunblock_filename} for reading.");
		flock UNBLOCK, 2;
		my @current = <UNBLOCK>;
		close (UNBLOCK);
		# Open file for writing, lock it, remove each entry from GAR IF it is in the hash
		open (UNBLOCK, ">${GARipunblock_filename}") or die ("CHECK_UNBLOCKFILE: Unable to open ${GARipunblock_filename} for updating.");
		flock UNBLOCK, 2;
		my ${line};
		foreach ${line} (@current) {
			chomp ${line};
			next if ${line} =~ /^iptables/; # skip over iptables text that should not exist in the first place
			if ($block_hash{${line}} eq "") {      # does the entry from the unblock file exist in the hash??
				# no, the entry does not exist in our block hash.
				&write_log (0,"Received notice from GUI : unblock ${line} : NOT IN HASH");
				# update the manual hashes because the unblock call is for the removal of a manually managed IP or CIDR block.
				&build_manual_hashes ("Rebuilding manual ipblock IPs and CIDR netblocks hashes...");
			} else {                             # the entry does exist
				&write_log (0,"Received notice from GUI : unblock ${line} : OK");
				# original call_unblock removes tracker files (2nd param) and skips processing from GUI notice since GUI had already removed the necessary info...
				#&call_unblock (${line}, "TRUE", "TRUE");
				# we're not removing the tracker files any more, so second parameter is now FALSE...
				#&call_unblock (${line}, "FALSE", "TRUE");
				# new call to call_unblock since switching to GARipblock removes tracker files (2nd param) and must process the iptables rules since the GUI doesn't remove then any more (3rd param)...
				&call_unblock (${line}, "TRUE", "FALSE");
			}
		}
		# Clear file
		truncate (UNBLOCK, 0);
		close (UNBLOCK);
	}
}

sub check_file_changed {
	my ${check_file} = $_[0];
	if (${check_file} eq ${alert_file}) {     # If we're testing the alert file and
		(${dev},${ino},${mode},${nlink},${uid},${gid},${rdev},${size},${atime},${mtime},${ctime},${blksize},${blocks}) = stat(${check_file});
		if (${size} < ${prev_alert_size}) {     # the filesize is less than last we checked,
			&write_log (2,"Alert filename changed. Reopening ${alert_file}");
			close (ALERT);                        # we need to close and
			open (ALERT, "${alert_file}");        # reopen it.
			${prev_alert_size} = ${size};
		} else {
			${prev_alert_size} = ${size};
		}
	}
	if (${check_file} eq ${opt_c}) {          # If we're testing the config file,
		(${dev},${ino},${mode},${nlink},${uid},${gid},${rdev},${size},${atime},${mtime},${ctime},${blksize},${blocks}) = stat(${check_file});
		if (${ctime} > ${prev_conf_ctime}) {    # If the creation timestamp is newer then last we checked,
			&write_log (2,"Config file changed. Reloading configuration options.");
			${prev_conf_ctime} = ${ctime};
			&load_config;
		} else {
			${prev_conf_ctime} = ${ctime};
		}
	}
	if (${check_file} eq ${GARignore_file}) { # If we're testing the ignore file,
		(${dev},${ino},${mode},${nlink},${uid},${gid},${rdev},${size},${atime},${mtime},${ctime},${blksize},${blocks}) = stat(${check_file});
		if (${ctime} > ${prev_ignore_ctime}) {  # If the modified timestamp is newer then last we checked,
			&write_log (2,"Ignore file changed.");
			${prev_ignore_ctime} = ${ctime};
			&build_ignore_hash ("Rebuilding ignore hash and CIDR array...");
		} else {
			${prev_ignore_ctime} = ${ctime};
		}
	}
	if (${check_file} eq ${GARtarget_file}) { # If we're testing the target file,
		(${dev},${ino},${mode},${nlink},${uid},${gid},${rdev},${size},${atime},${mtime},${ctime},${blksize},${blocks}) = stat(${check_file});
		if (${ctime} > ${prev_target_ctime}) {  # If the modified timestamp is newer then last we checked,
			&write_log (2,"Target file changed.");
			${prev_target_ctime} = ${ctime};
			&build_target_hash ("Rebuilding target hash...");
		} else {
			${prev_target_ctime} = ${ctime};
		}
	}
	if (${check_file} eq ${GARipblock_filename}) {  # If we're testing the ipblock conf file,
		(${dev},${ino},${mode},${nlink},${uid},${gid},${rdev},${size},${atime},${mtime},${ctime},${blksize},${blocks}) = stat(${check_file});
		if (${ctime} > ${prev_ipblock_ctime}) {       # If the modified timestamp is newer then last we checked,
			&write_log (2,"GARipblock file changed.");
			${prev_ipblock_ctime} = ${ctime};
			&build_manual_hashes ("Rebuilding manual ipblock IPs hash and CIDR netblocks array...");
		} else {
			${prev_ipblock_ctime} = ${ctime};
		}
	}
}

sub checkem {
	my (${source},${dest},${type},${id},${priority}) = @_;
	my (${gid},${sid},${rev}) = split(/:/,${id});
	my ${flag} = 0;
	&write_log (9,"entering checkem with ${source}, ${dest}, ${type}, ${id}, ${priority}");
	if (index(${type},"BLOCKED") > -1) {      # Does ${type} contain our keyword for special outbound trackers? (ie: failed logins)
		my ${xsource} = ${dest};                # Save destination address
		my ${xdest} = ${source};                # Save source address
		${source} = ${xsource};                 # Swap source with old destination address
		${dest} = ${xdest};                     # Swap destination with old source address
	}
	my ${statmsg} = "'${priority}' ${source}->${dest} ${type}";
	if (${ignore_gids}{${gid}} == 1) {        # check our ignored GIDs list
		&write_log (6,"${statmsg} - GID ${gid} is in GID Ignore list - No action taken.");
		return 1
	}
	if (${ignore_sids}{${gid}.":".${sid}} == 1) { # check our ignored SIDs list
		&write_log (6,"${statmsg} - SID ${gid}:${sid} is in SID Ignore list - No action taken.");
		return 1
	}
	if (${source} eq ${host_ip_address}) { # this should prevent us from nuking ourselves
		&write_log (6,"${statmsg} - Source = Host - No action taken.");
		return 1
	}
#	if ((${host_gateway_byte} ne "") && (${source} eq ${gateway_address})) { # this should prevent us from nuking our gateway
	if (${source} eq ${gateway_address}) { # this should prevent us from nuking our gateway
		&write_log (6,"${statmsg} - Source = Gateway - No action taken.");
		return 1
	}
	if ((${priority} && ${MIN_priority}) && (${priority} < ${MIN_priority})) { # check if priority is less than minimum.
		&write_log (6,"${statmsg} - Priority < MinPriority - No action taken.");
		return 1;
	}
	if ((${priority} && ${MAX_priority}) && (${priority} > ${MAX_priority})) { # check if priority is greater than maximum.
		&write_log (6,"${statmsg} - Priority > MaxPriority - No action taken.");
		return 1;
	}
	if ((${priority} == '') && (${MT_priority} eq 'no')) { # check if priority is blank and if we allow blocking on emptys.
		&write_log (6,"${statmsg} - Not blocking empty priorities - No action taken.");
		return 1;
	}
	if ($ignore_hash{${source}} == 1) { # check our ignored IPs list.
		&write_log (6,"${statmsg} - Source in ignore list - No action taken.");
		return 1;
	}
	if (Net::CIDR::cidrlookup(${source},@ignore_array)) { # check our ignored IPs CIDR list.
		&write_log (6,"${statmsg} - Source exists in an ignore list CIDR netblock - No action taken.");
		return 1;
	}
	if (Net::CIDR::cidrlookup(${source},@CIDR_array)) { # check the CIDR list of manually entered ipblock entries.
		&write_log (6,"${statmsg} - Source exists in an ipblock CIDR netblock - No action taken.");
		return 1;
	}
	if ($ipblock_hash{${source}} == 1) { # check our manual ipblock IPs list.
		&write_log (6,"${statmsg} - Source in manual ipblock IPs list - No action taken.");
		return 1;
	}
	# if the offending packet was sent to one of our RED WAN addresses, the
  # network address, or the broadcast address, then block it.
	if ($target_hash{${dest}} == 1) {
		&ipchain (${source}, ${dest}, ${type}, ${priority}, ${statmsg});
	} else {
		# you will see this if the destination was not in the $target_hash, and
    # the packet was not ignored before the target check. the target hash
    # contains all our RED WAN addresses, the network address, and the
    # broadcast address.
		&write_log(2,"${statmsg} - Odd, Has Host IP changed? (source = ${source}, dest = ${dest}) - No action taken.");
		&check_hostIP;
	}
}

sub create_tracker_file {
	my (${trackedIP}, ${msg}) = @_;
	my ${IPtracker_filename} = "${GARiptracker_dir}/${trackedIP}";
	&write_log (4,"Creating ${trackedIP}\'s tracker file");
	&write_log (5,"${trackedIP} => ${msg}");
	open (TRACKER, ">${IPtracker_filename}") or die ("CREATE_TRACKER_FILE: Unable to create tracker file ${IPtracker_filename}."); # create tracker file first
	flock TRACKER, 2;
	print TRACKER "${msg}\n";
	close (TRACKER);
}

sub update_tracker_file {
	my (${trackedIP}, ${msg}) = @_;
	my ${IPtracker_filename} = "${GARiptracker_dir}/${trackedIP}";
	&write_log (4,"Updating ${trackedIP}\'s tracker file");
	&write_log (5,"${trackedIP} => ${msg}");
	open (TRACKER, ">>${IPtracker_filename}") or die ("UPDATE_TRACKER_FILE: Unable to open tracker file ${IPtracker_filename} for appending.");
	flock TRACKER, 2;
	print TRACKER "${msg}\n";
	close (TRACKER);
}

sub update_ipblock_file {
	my (${methodtype},${source_ip},${bfmsg}) = @_;
	&write_log (9,"entering update_ipblock_file with ${methodtype}, ${source_ip}, ${bfmsg}");
	my ${themsg};
	${themsg} = substr(${bfmsg},0,255);
	if (${methodtype} eq "add") {
		&write_log (4,"Adding new entry to ipblock file");
		open (BLOCKFILE, ">>${GARipblock_filename}") or die ("UPDATE_IPBLOCK(add): Unable to open ${GARipblock_filename} for addition.");
		flock BLOCKFILE, 2;
		print BLOCKFILE "${themsg}\n";
		close (BLOCKFILE);
	} elsif (${methodtype} eq "update") {
		&write_log (4,"Updating entry in ipblock file");
		open (BLOCKFILE, "${GARipblock_filename}") or die ("UPDATE_IPBLOCK(update): Unable to open ${GARipblock_filename} for reading.");
		my @current = <BLOCKFILE>;
		close (BLOCKFILE);
		my ${line};
		open (BLOCKFILE, ">${GARipblock_filename}") or die ("UPDATE_IPBLOCK(update): Unable to open ${GARipblock_filename} for updating.");
		flock BLOCKFILE, 2;
		foreach ${line} (@current) {
			chomp(${line});
			my @temp = split(/\,/,${line});  # split the line into the fields separated by the commas.
			if (($temp[0] eq ${source_ip}) && ($temp[5] eq 'on')) {
				&write_log (9,"found $source_ip managed by GAR in ipblock file");
				&write_log (9,"old line  : ${line}");
				# source matches and GAR Added flag is 'on', so write the line with the updated comment.
				${line} = "$temp[0],$temp[1],$temp[2],$temp[3],${themsg},$temp[5]";
				&write_log (9,"new line  : ${line}");
			} else {
				# source does not match and/or GAR Added flag is 'off', so keep existing line.
				&write_log (9,"keep line : ${line}");
			}
			# write the line to block file. this is the existing line or the new one we just built.
			&write_log (9,"write line: ${line}");
			print BLOCKFILE "${line}\n";
		}
		close (BLOCKFILE);
	} else {
		&write_log (2,"UPDATE_IPBLOCK_FILE: unknown option '${methodtype}'");
	}
	# now make sure we update the the ipblock file's previous ctime variable since _we_ made the update
	(${dev},${ino},${mode},${nlink},${uid},${gid},${rdev},${size},${atime},${mtime},${ctime},${blksize},${blocks}) = stat(${GARipblock_filename});
	${prev_ipblock_ctime} = ${ctime};
	&write_log (9,"leaving update_ipblock_file");
}

sub ipchain {
	my (${source}, ${dest}, ${type}, ${priority}, ${logmsg}) = @_;
	&write_log (9,"entering ipchain with ${source}, ${dest}, ${type}, ${priority}");
	if (${priority} == 1) {
		${kicktime} = time() + ${TLimit1};
	} elsif (${priority} == 2) {
		${kicktime} = time() + ${TLimit2};
	} elsif (${priority} == 3) {
		${kicktime} = time() + ${TLimit3};
	} elsif (${priority} == 4) {
		${kicktime} = time() + ${TLimit4};
	} else {
		${kicktime} = time() + ${DefTLimit};
	}
	(${wkday},${month},${day},${time},${year}) = split(/\s+/, localtime(${kicktime}));
	${ktimestr} = "${day}-${month}-${year} ${time}";
	(${wkday},${month},${day},${time},${year}) = split(/\s+/, localtime);
	${blocktimestr} = "${day}-${month}-${year} ${time}";
	if ($block_hash{${source}} eq "") {   # new entry. add to ipblock and create tracker file with initial entry
		$block_hash{${source}} = ${kicktime};
		&write_log (0,"${logmsg} - Blocked till ${ktimestr}");
#		&update_ipblock_file ("add", "${source}", "${source},off,DROP,on,\<a href=\"javascript:displayGAR_Tracker('${source}');\"\>BLOCKED by GAR\</a\> ** ${blocktimestr} ** ${type},on");
		&update_ipblock_file ("add", "${source}", "${source},off,DROP,on,\<a href=\"javascript:displayGAR_Tracker('${source}');\"\>${blocktimestr}\</a\> ** ${type},on");
# new ipset method
		&write_log (4,"Adding ${source}\ to GARblockset");
		if ("$SWEprodvals{'VERSION'}" == "3.0") {
		    ${exitcode} = system ("/usr/sbin/ipset -A GARblockset ${source}");  # add the ip to the GARblockset
		    &write_log (5,"IPCHAIN: ipset -A result code : ${exitcode}");
		} else {
		    ${exitcode} = system ("/usr/sbin/ipset add GARblockset ${source}");
		    &write_log (5,"IPCHAIN: ipset add result code : ${exitcode}");
		}
		if (${exitcode} == -1) {
		    &write_log (2,"IPCHAIN: system ipset command #1 failed : '$!'");
		} elsif (${exitcode} & 127) {
		    ${exitcode} = (${exitcode} & 127);
		    &write_log (2,"Adding ${source} to GARblockset : DIED - signal ${exitcode} - '$!'");
		} elsif ((${exitcode} >> 8) > 0) {
		    ${exitcode} = (${exitcode} >> 8);
		    &write_log (2,"Adding ${source} to GARblockset : FAILED - exitcode ${exitcode} - '$!'");
		} else {
		    &write_log (5,"Adding ${source} to GARblockset : Success!");
		}
# end new ipset method
		# we keep the old tracker files so don't use create since it will truncate them.
		# instead, update them which should create them if they do not already exist.
#		&create_tracker_file (${source},"Active: ${blocktimestr} ** Expire: ${ktimestr} ** ${type}");
		&update_tracker_file (${source},"Active: ${blocktimestr} ** Expire: ${ktimestr} ** ${type}");
	} else {
		# We have already blocked this one, but snort detected another attack. So we will
		# update the time blocked. However, we will only update the expire time if it is
		# more in the future than the currently recorded time blocked.
		if ($block_hash{${source}} <= ${kicktime}) {
			# update the hash with the new expire time
			$block_hash{${source}} = ${kicktime};
			&write_log (3,"${logmsg} - Extended till ${ktimestr}");
#			&update_ipblock_file ("update", "${source}", "\<a href=\"javascript:displayGAR_Tracker('${source}');\"\>BLOCKED by GAR\</a\> ** ${blocktimestr} ** ${type}");
			&update_ipblock_file ("update", "${source}", "\<a href=\"javascript:displayGAR_Tracker('${source}');\"\>${blocktimestr}\</a\> ** ${type}");
			# if the existing expire time runs out before the newly calculated one
			&update_tracker_file (${source}, "Updated: ${blocktimestr} ** New Expire: ${ktimestr} ** ${type}");
		} else {
			# we have an entry that would reduce the expire time.
			# we never reduce the expire time. we only extend it.
			${kicktime} = $block_hash{${source}};    # retrieve current expire time to use in the retain update
			(${wkday},${month},${day},${time},${year}) = split(/\s+/, localtime(${kicktime}));
			${ktimestr} = "${day}-${month}-${year} ${time}";
			&write_log (3,"${logmsg} - Retained till ${ktimestr}");
#			&update_ipblock_file ("update", "${source}", "\<a href=\"javascript:displayGAR_Tracker('${source}');\"\>BLOCKED by GAR\</a\> ** ${blocktimestr} ** ${type}");
			&update_ipblock_file ("update", "${source}", "\<a href=\"javascript:displayGAR_Tracker('${source}');\"\>${blocktimestr}\</a\> ** ${type}");
			&update_tracker_file (${source}, "Updated: ${blocktimestr} ** Retained Expire: ${ktimestr} ** ${type}");
		}
	}
	&write_log (9,"leaving ipchain");
}

sub load_saved {
        my ${exitcode} = 0;
	my ${counter} = 0;
	if ( -e ${GARsaved_ipblock_filename}) {
		&write_log (3,"Loading saved IP records...");
		my ${line};
		open (SAVEDFILE, "${GARsaved_ipblock_filename}") or die ("LOAD_SAVED: Unable to open ${GARsaved_ipblock_filename} for reading.");
		my @current = <SAVEDFILE>;
		close (SAVEDFILE);
		open (BLOCKFILE, ">>${GARipblock_filename}") or die ("LOAD_SAVED: Unable to open ${GARipblock_filename} for appending.");
		flock BLOCKFILE, 2;
		foreach ${line} (@current) {
			chomp(${line});
			my @temp = split(/\|/,${line});       # split out the two parts of the saved record. 1st part is time stamp. 2nd part is ip portion
			my @t_line = split(/\,/,$temp[1]);    # split out the parts of the saved ipblock config line
			if ($block_hash{$t_line[0]} eq "") {  # do we already have an entry for this IP?
				print BLOCKFILE "$temp[1]\n";       # put the saved ipblock config line into the ipblock config file
#				if ($t_line[1] eq 'on') {           # does this entry have forced logging turned on?
#					system ("/sbin/iptables -A ipblock -s $t_line[0] -j LOG --log-prefix 'GAR-DROP: '");  # add the ip to the LOG table
#				}
# next two commented out for ipset usage
#				system ("/sbin/iptables -A GARcheckInbound -s $t_line[0] -j GARdrop");  # add the ip to the DROP table
#				system ("/sbin/iptables -A GARcheckOutbound -d $t_line[0] -j GARreject");  # add the ip to the DROP table
# new ipset method
        &write_log (4,"Adding ${t_line[0]} to GARblockset");
        if ("$SWEprodvals{'VERSION'}" == "3.0") {
          ${exitcode} = system ("/usr/sbin/ipset -A GARblockset ${t_line[0]}");  # add the ip to the GARblockset
          &write_log (5,"LOAD_SAVED: ipset -A result code : ${exitcode}");
        } else {
          ${exitcode} = system ("/usr/sbin/ipset add GARblockset ${t_line[0]}");
          &write_log (5,"LOAD_SAVED: ipset add result code : ${exitcode}");
        }
        if (${exitcode} == -1) {
		      &write_log (2,"LOAD_SAVED: system ipset command #1 failed : '$!'");
        } elsif (${exitcode} & 127) {
          ${exitcode} = (${exitcode} & 127);
          &write_log (2,"Adding ${t_line[0]} to GARblockset : DIED - signal ${exitcode} - '$!'");
        } elsif ((${exitcode} >> 8) > 0) {
          ${exitcode} = (${exitcode} >> 8);
          &write_log (2,"Adding ${t_line[0]} to GARblockset : FAILED - exitcode ${exitcode} - '$!'");
        } else {
          &write_log (5,"Adding ${t_line[0]} to GARblockset : Success!");
        }
# end new ipset method
				$block_hash{$t_line[0]} = $temp[0];  # put the saved expiry for the IP in the block hash
				${counter}++;
			} else {
				&write_log (2,"Skipping duplicate saved entry for $t_line[0].");
			}
		}
		close (BLOCKFILE);                            # close the file when we're done
		# now make sure we update the the ipblock file's previous ctime variable since _we_ made the update
		(${dev},${ino},${mode},${nlink},${uid},${gid},${rdev},${size},${atime},${mtime},${ctime},${blksize},${blocks}) = stat(${GARipblock_filename});
		${prev_ipblock_ctime} = ${ctime};
		unlink ${GARsaved_ipblock_filename};        # delete the saved file since we don't need it any more
		&write_log (4,"Loaded ${counter} saved IP records...");
	} else {
		&write_log (3,"No saved IP records to load...");
	}
}

# Function getValue() opens the specified file, reads the single line in it, and closes the
#   file. If the open() fails, the default value is "" (NULL string).
sub getValue {
  my ($file) = @_;

  # If the open fails, the var will be empty (NULL string).
  my $value = "";

  # Give it a go.
  if (open(FILE, "<$file")) {
    # There is one line; it has no terminating NL.
    $value = <FILE>;
    close FILE;
    # This chomp isn't needed for this specific purpose, but is here to make the
    #   function a little more generic.
    chomp $value;
  }

  # Return the value even if nothing was read.
  return $value;
}

sub _calc_netmask {
  my($subnet) = @_;
     
  # e.g.: 10.0.0.0/24 192.168.1.0/16
  my($network, $netbit) = split /\//, $subnet;
             
  my $_bit         = ( 2 ** (32 - $netbit) ) - 1;
  my ($full_mask)  = unpack( "N", pack( "C4", split(/\./, '255.255.255.255') ) );
  my $netmask      = join( '.', unpack( "C4", pack( "N", ( $full_mask ^ $_bit ) ) ) );
                            
  return $netmask;
}

sub load_config {
	if (${opt_c} eq "") {
    ${opt_c} = "${defaultconfig_filename}";
  }
	if (! -e ${opt_c}) {
    die ("LOAD_CONFIG: Config file ${opt_c} does not exist!");
  }
  
  ##### start of new configs being read from SWE maintained files in RED directory #####
  my $sweRed = "/var/smoothwall/red";
  
  # File 'active' exists only when RED is up; that is, PPP is up and running, dhcpcd got an
  #   address, or RED is STATIC. If PPP is down or dhcpcd lost the lease, the files are emptied
  #   and 'active' is deleted. But the rest of the files should always exist, empty or not.
  
  if (-f "$sweRed/active")
  {
    # fetch the addresses
    $interface = &getValue("$sweRed/iface");
    $host_ip_address = &getValue("$sweRed/local-ipaddress");
    $gateway_address = &getValue("$sweRed/remote-ipaddress");
#    $DNS1 = &getValue("$sweRed/dns1");
#    $DNS2 = &getValue("$sweRed/dns2");
    $host_ip_netmask = &getValue("$sweRed/dhcp-netmask");

    # Process the data, but first check to see each value is not "" (empty).
  }
    else
  {
    # Do something to fail gracefully. 'die' can cause the UI to not display correctly,
    #   or at all, when used in a .cgi script.
  }

  ##### end of new config reading #####

	open (CONF, ${opt_c}) or die ("LOAD_CONFIG: Cannot read the config file ${opt_c}, $!");
	while (<CONF>) {
		chomp;
		next if (/^\s*$/);  #skip blank lines
		next if (/^#/);     # skip comment lines
		if (/^LogFile\s+(.*)/i)         {${logfile} = $1;}
#		if (/^Interface\s+(.*)/i)       {${interface} = $1;}
#		if (/^HostIpAddr\s+(.*)/i)      {${host_ip_address} = $1;}
#		if (/^HostGatewayByte\s+(.*)/i) {${host_gateway_byte} = $1;}
		if (/^AlertFile\s+(.*)/i)       {${alert_file} = $1;}
		if (/^IgnoreFile\s+(.*)/i)      {${GARignore_file} = $1;}
		if (/^TargetFile\s+(.*)/i)      {${GARtarget_file} = $1;}
		if (/^MaxPriority\s+(.*)/i)     {${MAX_priority} = $1;}
		if (/^MinPriority\s+(.*)/i)     {${MIN_priority} = $1;}
		if (/^MTPriority\s+(.*)/i)      {${MT_priority} = $1;}
		if (/^ForceLogging\s+(.*)/i)    {${forced_logging} = $1;}
		if (/^LogMsgLevel\s+(.*)/i)     {${logmsglevel} = $1;}
		if (/^IgnoreSIDs?\s+(.*)/i) {
			${ignore_sids} = $1;
			for $k (split(/\,/,${ignore_sids})) { # split the IgnoreSIDs line on the commas
				${ignore_sids}{$k} = 1;
			}
		}
		if (/^IgnoreGIDs?\s+(.*)/i) {
			${ignore_gids} = $1;
			for $k (split(/\,/,${ignore_gids})) { # split the IgnoreGIDs line on the commas
				${ignore_gids}{$k} = 1;
			}
		}
		if (/^TimeLimit\s+(.*)/i) {${DefTLimit} = $1;}
		if (/^Pri1TimeLimit\s+(.*)/i) {${TLimit1} = $1;}
		if (/^Pri2TimeLimit\s+(.*)/i) {${TLimit2} = $1;}
		if (/^Pri3TimeLimit\s+(.*)/i) {${TLimit3} = $1;}
		if (/^Pri4TimeLimit\s+(.*)/i) {${TLimit4} = $1;}
	}
	(${dev},${ino},${mode},${nlink},${uid},${gid},${rdev},${size},${atime},${mtime},${ctime},${blksize},${blocks}) = stat(${opt_c});
	${prev_conf_ctime} = ${ctime};
	if (defined ${GARignore_file}) {
		(${dev},${ino},${mode},${nlink},${uid},${gid},${rdev},${size},${atime},${mtime},${ctime},${blksize},${blocks}) = stat(${GARignore_file});
		${prev_ignore_ctime} = ${ctime};
	}
	if (defined ${GARtarget_file}) {
		(${dev},${ino},${mode},${nlink},${uid},${gid},${rdev},${size},${atime},${mtime},${ctime},${blksize},${blocks}) = stat(${GARtarget_file});
		${prev_target_ctime} = ${ctime};
	}
	&validate_config;
	&build_ignore_hash ("Building ignore hash and CIDR array...");
	&build_target_hash ("Building target hash...");
	&build_manual_hashes ("Building manual ipblock IPs hash and CIDR netblocks array...");
	&report_config;
}

sub addrtoint { return( unpack( "N", pack( "C4", split( /[.]/,$_[0] ) ) ) ) };
sub inttoaddr { return( join( ".", unpack( "C4", pack( "N", $_[0] ) ) ) ) };

sub set_other_addresses {
#	${network_address} = ${host_ip_address};
#	${network_address} =~ s/\d+$/0/;
#	if (defined ${host_gateway_byte}) {
#		${gateway_address} = ${host_ip_address};
#		${gateway_address} =~ s/\d+$/${host_gateway_byte}/;
#	}
#	${broadcast_address} = ${host_ip_address};
#	${broadcast_address} =~ s/\d+$/255/;

  ${network_address_int} = addrtoint(${host_ip_address}) & addrtoint(${host_ip_netmask});
  ${broadcast_address_int} = $network_address_int | ~addrtoint(${host_ip_netmask});
  ${network_address} = inttoaddr($network_address_int);
  ${broadcast_address} = inttoaddr($broadcast_address_int);
}

sub validate_config {
	if (${logfile} eq "") {
		print "Warning! LogFile is undefined. Assuming ${defaultlog_filename}.\n";
		${logfile} = "${defaultlog_filename}";
	}
	if (-e ${logfile}) {
		if (! -w ${logfile}) {
			print "VALIDATE_CONFIG: Warning! Log file ${logfile} is not writeable! Exiting...\n";
			die;
		}
	} else {
		system ('/bin/touch', "${logfile}");
	}
	if (!defined ${logmsglevel}) {
		print "Warning! LogMsgLevel is undefined. Defaulting to level 3.\n";
		${logmsglevel} = 3;
	}
	&write_log (0,"----------------------------------------");
	&write_log (0,"${appID} initializing...");
	&write_log (0,"Running on SWE".$SWEprodvals{'VERSION'});
	if (${interface} eq "") {
		&write_log (1,"Fatal! Interface is undefined. Please define it in ${opt_c} with keyword 'Interface'.");
		die;
	}
	if (!defined ${host_ip_address}) {
		&write_log (2,"Warning! HostIpAddr is undefined. Checking ${interface}...");
		${host_ip_address} = &get_host_ip(${interface});
		&write_log (0,"IP ${host_ip_address} assigned on ${interface}.");
	}
	if (${host_ip_address} !~ /\d+\.\d+\.\d+\.\d+/) {
		&write_log (2,"This ip address is bad : ${host_ip_address}");
		&write_log (1,"I need a good host ip address.");
		die;
	}
#  if ((${host_gateway_byte} eq "") && (index(${interface},"ppp") == -1)) {
#    &write_log (2,"Warning! HostGatewayByte is undefined. Gateway will not be in ignore list.");
#  }
	if (${iptables_up} == "no") {
		&write_log (4,"Running GAR.up");
		system ("${GAR_Home_dir}/etc/rc.d/rc.GAR.up");
		${iptables_up} = "yes";
	}
	&set_other_addresses;
	if (${alert_file} eq "") {
		&write_log (2,"Warning! AlertFile is undefined. Assuming ${defaultalert_filename}");
		${alert_file} = "${defaultalert_filename}";
	}
	if (${GARignore_file} eq "") {
		&write_log (2,"Warning! IgnoreFile is undefined. Using default ignore list of hostip and gateway.");
	}
	if (!defined ${MAX_priority}) {
		&write_log (2,"Warning! MaxPriority not defined. Defaulting to 2.");
		${MAX_priority} = 2;
	}
	if (!defined ${MIN_priority}) {
		&write_log (2,"Warning! MinPriority not defined. Defaulting to 1.");
		${MIN_priority} = 1;
	}
	if (!defined ${MT_priority}) {
		&write_log (2,"Warning! MTPriority not defined. Defaulting to 'yes'.");
		${MT_priority} = "yes";
	}
	if (!defined ${forced_logging}) {
		&write_log (2,"Warning! ForceLogging not defined. Defaulting to 'no'.");
		${forced_logging} = "no";
	}
	if (!defined ${DefTLimit}) {
		&write_log (2,"Warning! Default time limit not defined. Defaulting to 999999999 (~31.5 years).");
		${DefTLimit} = 999999999; # 31.5 years
	}
	if ((!defined ${TLimit1}) || (${TLimit1} == 0)) {
		&write_log (2,"Warning! Time limit 1 not defined. Using default time limit.");
		${TLimit1} = ${DefTLimit};
	}
	if ((!defined ${TLimit2}) || (${TLimit2} == 0)) {
		&write_log (2,"Warning! Time limit 2 not defined. Using default time limit.");
		${TLimit2} = ${DefTLimit};
	}
	if ((!defined ${TLimit3}) || (${TLimit3} == 0)) {
		&write_log (2,"Warning! Time limit 3 not defined. Using default time limit.");
		${TLimit3} = ${DefTLimit};
	}
	if ((!defined ${TLimit4}) || (${TLimit4} == 0)) {
		&write_log (2,"Warning! Time limit 4 not defined. Using default time limit.");
		${TLimit4} = ${DefTLimit};
	}
}

sub report_config {
	&write_log (0,"Logging Message Level ${logmsglevel}");
	&write_log (7,"Logfile         : ${logfile}");
	&write_log (7,"Interface       : ${interface}");
	&write_log (7,"Host IP         : ${host_ip_address}");
#	if (defined ${host_gateway_byte}) {
#		&write_log (7,"Host GW Byte    : ${host_gateway_byte}");
#	}
	&write_log (7,"Host IP Netmask : ${host_ip_netmask}");
	&write_log (7,"Network Address : ${network_address}");
	&write_log (7,"Gateway Address : ${gateway_address}");
	&write_log (7,"BCast Address   : ${broadcast_address}");
	&write_log (7,"Alert File      : ${alert_file}");
	&write_log (7,"Ignore File     : ${GARignore_file}");
	&write_log (7,"Target File     : ${GARtarget_file}");
	&write_log (7,"Max. Priority   : ${MAX_priority}");
	&write_log (7,"Min. Priority   : ${MIN_priority}");
	&write_log (7,"Empty Priority  : ${MT_priority}");
	&write_log (7,"Force Logging   : ${forced_logging}");
	&write_log (7,"Def Timelimit   : ${DefTLimit} seconds == ".(${DefTLimit}/60)." minutes == ".(${DefTLimit}/3600)." hours == ".(${DefTLimit}/86400)." days");
	&write_log (7,"Pri 1 Timelimit : ${TLimit1} seconds == ".(${TLimit1}/60)." minutes == ".(${TLimit1}/3600)." hours == ".(${TLimit1}/86400)." days");
	&write_log (7,"Pri 2 Timelimit : ${TLimit2} seconds == ".(${TLimit2}/60)." minutes == ".(${TLimit2}/3600)." hours == ".(${TLimit2}/86400)." days");
	&write_log (7,"Pri 3 Timelimit : ${TLimit3} seconds == ".(${TLimit3}/60)." minutes == ".(${TLimit3}/3600)." hours == ".(${TLimit3}/86400)." days");
	&write_log (7,"Pri 4 Timelimit : ${TLimit4} seconds == ".(${TLimit4}/60)." minutes == ".(${TLimit4}/3600)." hours == ".(${TLimit4}/86400)." days");
	&write_log (7,"Ignored GIDs    : ${ignore_gids}");
	&write_log (7,"Ignored SIDs    : ${ignore_sids}");
}

sub write_log {
	my ${daystr};
	my (${msgrptlvl}, ${message}) = @_;
	if (${msgrptlvl} <= ${logmsglevel}) {
		(${wkday},${month},${day},${time},${year}) = split(/\s+/, localtime);
		if (${day} <= 9) {
			${daystr} = " ${day}";
		} else {
			${daystr} = ${day};
		}
		open (LOG, ">>${logfile}");
		print LOG "${month} ${daystr} ${time} $msgsymbols[${msgrptlvl}] ${message}\n";
		close (LOG);
	}
}

sub daemonize {
	my (${home});
	if (fork()) {
		# parent
		exit(0);
	} else {
		# child
		&write_log (0,"Becoming a daemon - process id $$");
		open (GPID, ">>${GARpid_filename}");
		print GPID $$;
		close (GPID);
		${home} = (getpwuid($>))[7] or die ("DAEMONIZE: No home directory!");
		chdir(${home});   # go to my homedir
		setpgrp(0,0);     # become process leader
		close (STDOUT);
		close (STDIN);
		close (STDERR);
	}
}

sub get_host_ip {
	my ${interface} = $_[0];
	my ${ip};
	my ${ipnoted} = 0;
	while (${ip} eq "") {
#		open (IFCONFIG, "/sbin/ifconfig ${interface} |");
		open (IFCONFIG, "/usr/sbin/ip addr show ${interface} |");
		while (<IFCONFIG>) {
#			if (/inet addr:(\d+\.\d+\.\d+\.\d+)/) {
			if (/inet (\d+\.\d+\.\d+\.\d+)/) {
				${ip} = $1;
			}
			if (index(${interface},"ppp") > -1) {
#				if (/P-t-P:(\d+\.\d+\.\d+\.\d+)/) {
				if (/peer (\d+\.\d+\.\d+\.\d+)/) {
					${gateway_address} = $1;
				}
			}
		}
		close (IFCONFIG);
		if ((${ip} eq "") && (!${ipnoted})) {
			&write_log (2,"Waiting for ${interface} to stabilize.");
			${ipnoted} = 1;
			sleep 1;
		}
	}
	return ${ip};
}

sub expire_blocks {
	my ${source};
	my ${time} = time();
	foreach ${source} (keys %block_hash) {
		if ($block_hash{${source}} < ${time}) {
			&write_log (0,"Expiring block of ${source}");
			# to delete the tracker files, the second param is TRUE. FALSE to keep them...
			# we're not removing the tracker files any more,
			# so second parameter is now FALSE...
			&call_unblock (${source}, "TRUE", "FALSE");
			#&call_unblock (${source}, "FALSE", "FALSE");
			&write_log (5,"Done expiring block of ${source}");
		}
	}
}

sub call_unblock {
	my (${source}, ${killtrackfile}, ${GUI_unblock}) = @_;
	my ${exitcode} = 0;
	my ${IPtracker_filename} = "${GARiptracker_dir}/${source}";
	my ${update_manual_hashes} = 0;
	# kill the entry from the block_hash
	#  do this kill first in case the source is no longer
	#  in the ipblock file for some unfathomable reason. this
	#  will prevent GAR from looping over and over trying to
	#  remove a source that exists only in its internal hash.
	&write_log (5,"Removing ${source} from internal hash");
	delete ($block_hash{${source}});
	&write_log (5,"Looking for ${source} in ${GARipblock_filename} file");
	if (${GUI_unblock} eq "FALSE") {
		&write_log (9,"call_unblock : \${GUI_unblock} eq FALSE");
		open (BLOCKFILE, "${GARipblock_filename}") or die ("CALL_UNBLOCK: Unable to open ${GARipblock_filename} for reading.");
		my @current = <BLOCKFILE>;
		close (BLOCKFILE);
		my ${line};
		open (BLOCKFILE, ">${GARipblock_filename}") or die ("CALL_UNBLOCK: Unable to open ${GARipblock_filename} for updating.");
		flock BLOCKFILE, 2;
		foreach ${line} (@current) {
			chomp(${line});
			my @temp = split(/\,/,${line});
			if ($temp[0] eq ${source}) {
				&write_log (5,"Located ipblock entry for ${source}");
				if ($temp[5] eq 'on') {      # "GAR Added" flag is 'on' and source matches, so remove entries
					&write_log (5,"${source} is GAR managed");
# new ipset method
					&write_log (4,"Removing ${source}\ from GARblockset");
					if ("$SWEprodvals{'VERSION'}" == "3.0") {
						${exitcode} = system ("/usr/sbin/ipset -D GARblockset ${source}");
						&write_log (5,"CALL_UNBLOCK: ipset -D result code : ${exitcode}");
					} else {
						${exitcode} = system ("/usr/sbin/ipset del GARblockset ${source}");
						&write_log (5,"CALL_UNBLOCK: ipset del result code : ${exitcode}");
					}
          if (${exitcode} == -1) {
            &write_log (2,"CALL_UNBLOCK: system ipset command #1 failed : '$!'");
          } elsif (${exitcode} & 127) {
            ${exitcode} = (${exitcode} & 127);
            &write_log (2,"Removing ${source} from GARblockset : DIED - signal ${exitcode}");
          } elsif ((${exitcode} >> 8) > 0) {
            ${exitcode} = (${exitcode} >> 8);
            &write_log (2,"Removing ${source} from GARblockset : FAILED - exitcode ${exitcode}");
          } else {
            &write_log (5,"Removing ${source} from GARblockset : Success!");
          }
# end new ipset method
          if (${killtrackfile} eq "TRUE") {          # should we delete the tracking file?  TRUE: normal operation, FALSE: shutdown
            &write_log (3,"Looking for ${source}\'s tracker file");
            if (-e ${IPtracker_filename}) {    # does the tracking file exist?
              &write_log (0,"Removing ${source}\'s tracker file");
              if (unlink ${IPtracker_filename}) {
                &write_log (5,"Removing ${source}\'s tracker file : Success!");
              } else {
                &write_log (2,"Removing ${source}\'s tracker file : Failed: $!");
              }
            } else {
              &write_log (2,"${source}\'s tracker file does not exist.");
            }
          } else {
            &write_log (3,"Keeping ${source}\'s tracker file");
          }
				} else {
          # GAR Added flag is off... what??
					&write_log (2,"${source} is NOT GAR managed???");
				}
			} else {
				# Put the line back in the ipblock file since it does not match
        # the source IP
				next if ${line} =~ /^iptables/; # skip over iptables error text
                                        # that should not exist in the
                                        # first place
				next if ${line} =~ /^Bad/; # skip over ipset error text that
                                   # should not exist in the first place
				&write_log (9,"placing \"${line}\" back in ${GARipblock_filename}");
				print BLOCKFILE "${line}\n";
			}
		}
		close (BLOCKFILE);
		# now make sure we update the the ipblock file's previous ctime
    # variable since have just rewritten the data
		(${dev},${ino},${mode},${nlink},${uid},${gid},${rdev},${size},${atime},${mtime},${ctime},${blksize},${blocks}) = stat(${GARipblock_filename});
		${prev_ipblock_ctime} = ${ctime};
	} else {
		# the ipblock GUI page has indicated change in a GAR managed rule
    # and requested its removal from our internal block hash and then
    # kill its associated trackerfile. we also need to rebuild the
    # manual hashes in case the change was to switch the IP address to
    # manually managed so we can keep up with what is not managed by us.
		&write_log (9,"call_unblock : \${GUI_unblock} eq TRUE");
		&write_log (5,"Removing ${source} from internal hash");
		delete ($block_hash{${source}});
		if (${killtrackfile} eq "TRUE") {      # should we delete the tracking file?  TRUE: normal operation, FALSE: shutdown
			&write_log (3,"Looking for ${source}\'s tracker file");
			if (-e ${IPtracker_filename}) {    # does the tracking file exist?
				&write_log (0,"Removing ${source}\'s tracker file");
				if (unlink ${IPtracker_filename}) {
					&write_log (5,"Removing ${source}\'s tracker file : Success!");
				} else {
					&write_log (2,"Removing ${source}\'s tracker file : Failed: $!");
				}
			} else {
				&write_log (2,"${source}\'s tracker file does not exist.");
			}
		} else {
			&write_log (3,"Keeping ${source}\'s tracker file");
		}
		&build_manual_hashes ("Rebuilding manual ipblock IPs hash and CIDR netblocks array...");
	}
}

sub sig_handler_setup {
    &write_log (4,"Setting up signal handlers.");
    $SIG{TERM} = \&clean_up_and_exit; # kill or kill -15
    $SIG{KILL} = \&clean_up_and_exit; # kill -9
    $SIG{QUIT} = \&clean_up_and_exit; # kill -3
    $SIG{HUP} = \&clean_up_and_exit;  # kill -1
    $SIG{__DIE__} = \&GARdie;         # die() handler
}

sub check_extra_trackers {
	# let's hunt down extraneous tracker files possibly left behind when
	# entries were modified in the GUI page. do this before cleaning out
	# the active block hash so we have something to compare with.
	opendir(DIR, ${GARiptracker_dir}) or die ("CHECK_EXTRA_TRACKERS: Can't opendir ${GARiptracker_dir}: $!");
	@trackers = grep { /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/ && -f "${GARiptracker_dir}/$_" } readdir(DIR);
	closedir DIR;
	my $trackers_file_count = scalar @trackers;
	if ($trackers_file_count > 0) {
		&write_log (3,"Searching for extraneous tracker files...");
		foreach $file (@trackers) {
			$match = 0;
			foreach ${source} (keys %block_hash) {
				if ($file eq ${source}) {
					$match = 1;
				}
			}
			if (!$match) {   # the trackerfile's name does not exist in the block hash
				$ip_tracker_file = "${GARiptracker_dir}/$file";
				&write_log (4,"Removing extraneous tracker file: $ip_tracker_file");
				if (unlink ${IPtracker_filename}) {
					&write_log (5,"Removing ${source}\'s tracker file : Success!");
				} else {
					&write_log (2,"Removing ${source}\'s tracker file : Failed: $!");
				}
			}
		}
		&write_log (3,"Search and removal complete...");
	} else {
		&write_log (3,"No tracker files to search through...");
	}
}

sub GARdie {
  my $reason = @_;
  print "$reason\n";
	if ( -w ${logfile} ) {
    &write_log (1,"$reason");
  }
  die;
}

sub clean_up_and_exit {
	&write_log (0,"Received kill signal. Shutting down...");
	my ${source};
	my $hash_source;
	my $block_hash_count = scalar keys %block_hash;
	if ($block_hash_count) {
		&write_log (0,"Saving current blocked IP records...");
		open (IPBLOCK_FILE, "${GARipblock_filename}") or die ("CLEAN_UP_AND_EXIT: Unable to open ${GARipblock_filename} for reading.");
		my @current = <IPBLOCK_FILE>;
		close (IPBLOCK_FILE);
		my ${line};
		open (IPSAVE_FILE, ">${GARsaved_ipblock_filename}") or die ("CLEAN_UP_AND_EXIT: Unable to open ${GARsaved_ipblock_filename} for writing.");
		flock IPSAVE_FILE, 2;
		my $total = @current;
		&write_log (3,"Working with $total blocked IP records...");
		my ${counter} = 0;
		foreach ${line} (@current) {
			chomp(${line});
			my @temp = split(/\,/,${line});
			if ($temp[5] eq 'on') {                           # "GAR Added" flag is 'on'
				foreach $hash_source (keys %block_hash) {     # loop thru the hash entries looking for the IP
					if ($hash_source eq $temp[0]) {           # found the hash entry for the current blocked IP
						my $expiry = $block_hash{$temp[0]};   # get the expiry date and time from the hash entry
						print IPSAVE_FILE "$expiry\|${line}\n";        # write expiry and existing ipblock config line to save file
						${counter}++;
					}
				}
			}
		}
		close (IPSAVE_FILE);
		&write_log (0,"Saved ${counter} blocked IP records...");
		if (${counter} == 0) {
			unlink ${GARsaved_ipblock_filename};
		}
		&check_extra_trackers;
		# now unblock each entry for shutdown...
		&write_log (3,"Unblocking and removing IPs...");
		foreach ${source} (keys %block_hash) {
			&write_log (9,"Calling call_unblock with ${source} FALSE FALSE");
			&call_unblock (${source}, "FALSE", "FALSE");
			&write_log (9,"Returned from call_unblock");
		}
		&write_log (3,"Unblocking and removal complete...");
	} else {
		&write_log (0,"No IPs recorded as blocked...");
		&check_extra_trackers;
	}
	close (ALERT);                       # since we keep it open during operation.
	if (${iptables_up} == "yes") {
#		&write_log (1,"Waiting 5 for iptables to settle");
#		sleep 5;
		&write_log (4,"Running rc.GAR.down");
		system ("${GAR_Home_dir}/etc/rc.d/rc.GAR.down");
#		&write_log (1,"Waiting 5 for iptables to settle");
#		sleep 5;
		${iptables_up} = "no";
	}
#	&write_log (5,"Removing unblock file: ${GARipunblock_filename}");
#	unlink ${GARipunblock_filename};        # delete the unblock file. it will be recreated at next startup
#	&write_log (3,"Reloading ipblock table");
#	system ('/usr/bin/smoothcom', 'setipblock');
	&write_log (5,"Removing pid file: ${GARpid_filename}");
	unlink ${GARpid_filename};                    # delete our PID file
	&write_log (0,"Shutdown complete.");
	exit;                                # get out of Dodge City!
}
