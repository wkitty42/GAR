#!/usr/bin/perl
# Guardian Active Response - Smoothwall Express IP Blocker for Snort Alerts
#
my $partial_secs = 100;   # how many parts to divide a second into
my $loop_secs = .5;       # how many seconds between housework chores
#
# This version is an extensive rewrite and reorganization based on v1.85. This
# is being done specifically for Smoothwall3 by wkitty42. Thanks to s-t-p for
# porting NetWhiz's SWE2 version to SWE3 and to NetWhiz for doing the work to
# make this available and operational on SW machines. Some code has stayed the
# same. Numerous new routines have been added. Some existing code has been
# split into seperate routines. A lot of code has been massaged a bit for
# compatibility with the new features and abilities. And finally, some code
# has simply been removed.
#

use lib "/usr/lib/smoothwall";
use header qw( :standard );
use Getopt::Std;

require Time::HiRes;
require Net::CIDR;

getopts ('hc:kv');

my @msgsymbols = (" ","!","\?","*","+","-","\$","#",":","\%");
my $modroot = "$swroot/mods/GAR";
my $ip_tracker_dir = "$modroot/var/db";           # the source IP must be appended to this for tracking
my $garversion_file_name = "$modroot/installed";
my $ip_block_file_name = "$ip_tracker_dir/GARipblock";
my $saved_ip_block_file_name = "$ip_tracker_dir/saved";
my $ip_unblock_file_name = "$ip_tracker_dir/unblock";

open (GARVERFILE, "$garversion_file_name") or die "GARVERFILE: Unable to open $garversion_file_name for reading.";
my $progname = <GARVERFILE>;
close (GARVERFILE);
chomp $progname;
($progname,$garversion) = split(/ /,$progname);

my $pid_file = "/var/run/$progname.pid";
my $iptables_up = "no";
# Make sure ip_block_file_name exists on startup
system ('/bin/touch', "$ip_block_file_name");
system ('/bin/chown', "nobody:nobody", "$ip_block_file_name");
# Init ip_unblock_file_name on startup
system ('/bin/touch', "$ip_unblock_file_name");
system ('/bin/chown', "nobody:nobody", "$ip_unblock_file_name");

if (defined $opt_h) {
    print "$progname $garversion\n";
    print "$0 [-hkv]||[-c config]||[-a xxx.xxx.xxx.xxx]||[-d xxx.xxx.xxx.xxx]||[-i xxx.xxx.xxx.xxx]\n";
    print " -h  show this help and exit\n";
    print " -v  display GAR version and exit\n";
    print " -k  terminate currently running GAR\n";
    print " -c  specifiy a configuration file other than the default\n";
#    print " -a  add IP xxx.xxx.xxx.xxx to guardian managed block list";
#    print " -d  delete IP xxx.xxx.xxx.xxx from guardian managed block list";
#    print " - i add IP xxx.xxx.xxx.xxx to the guardian ignore list";
    exit;
}

if (defined $opt_v) {
    print "$progname $garversion\n";
    exit;
}

if (defined $opt_k) {
    if (! -e $pid_file) { die "OPT_K: PID file, $pid_file, not found. GAR is not running.\n"; }
    open (GPID, "$pid_file") or die "OPT_K: Cannot read pid file $pid_file\n";
    my $pid = <GPID>;
#    while (<GPID>) {
#	chomp;
#	$pid = $_;
#    }
    close (GPID);
    chomp $pid;
    print "Sending termination signal to $pid.\n";
    system ('/usr/bin/kill', "$pid");
    exit;
}

if ( -e $pid_file) { die "PID file, $pid_file, found. $progname is already running.\n"; }

&sig_handler_setup;
&load_config;
&load_saved;
&daemonize;

open (ALERT, $alert_file) or die "can't open alert file: $alert_file: $!\n";
seek (ALERT, 0, 2); # set the position to EOF, this is the same as a tail -f :)

my $counter = 0;
my $sleep_timer = 1 / $partial_secs;            # actual partial seconds value
my $loop_timer = $loop_secs / $sleep_timer;     # times thru the loop to equal $loop_secs seconds
# main processing loop
for (;;) {
#    sleep 1;
    Time::HiRes::sleep ($sleep_timer);          # sleep for $sleep_timer parts of a second
    if (seek (ALERT,0,1)) {
	while (<ALERT>) {
	    chomp;
	    &write_log (8,$_);
	    # we're working with a snort.alert type file (for backwards compatibility??)
	    if (/\[\*\*\]\s+(.*)\s+\[\*\*\]/){
		$type = $1;
		&write_log (9,"found type: $type");
	    }
	    if ($type =~ /^\[([0-9:]+)\]\s+/){ $id = $1; }
	    if (/\[Priority: (\d+)\]/i) {
		$priority = $1;
		&write_log (9,"found priority: $priority");
	    }
	    if (/(\d+\.\d+\.\d+\.\d+):?\d* -\> (\d+\.\d+\.\d+\.\d+):?\d*/) {
		$src_ip = $1;
		$dst_ip = $2;
		if ($dst_ip eq "") { $dst_ip = 0; }
		&write_log (9,"found src and dst: $src_ip -\> $dst_ip");
		&checkem ($src_ip, $dst_ip, $type, $id, $priority);  # src and dst addrs are the last things we need to call checkem
		&write_log (9,"returned from checkem");
		$priority = ''; # make sure priority is empty for next loop otherwise prev pri is still in place on empty pri alerts
	    }
	}
    }
    if ($counter == $loop_timer) {                 # We do these chores every $loop_secs seconds (eg: 5 seconds / .0625 = 80 loop traversals)
	&expire_blocks;                            # remove blocked entries if they are expired
	&check_unblockfile;                        # check if there are any entries to unblock from the GUI
	&check_file_changed ($alert_file);         # check if the alert file has been rotated under us
	&check_file_changed ($opt_c);              # check if the config file has been modified under us
	&check_file_changed ($ip_block_file_name); # check if the ipblock file has been modified under us
	if (defined $ignore_file) {
	    &check_file_changed ($ignore_file);    # check if the ignore file has been modified under us
	}
	if (defined $target_file) {
	    &check_file_changed ($target_file);    # check if the target file has been modified under us
	}
	&check_hostIP;                             # check if our WAN IP has changed
	$counter = 0;
    } else {
	$counter++;
    }
}

sub build_ignore_hash {
    my $tmsg = $_[0];
    &write_log (3,$tmsg);
    # This would cause us to ignore all broadcasts if it got set.
    # However if unset, then the attacker could spoof the packet to make
    # it look like it came from the network, and a reply to the spoofed packet
    # could be seen if the attacker were on the local network.
    # $ignore_hash{$network_address} = 1;

    # same thing as above, just with the broadcast instead of the network.
    # $ignore_hash{$broadcast_address} = 1;

    my $hash_counter = 0;
    my $array_counter = 0;
    if (defined $gateway_address) {
	$ignore_hash{$gateway_address} = 1;
    }
    $ignore_hash{$host_ip_address} = 1;
    @ignore_array = ();

    if (($ignore_file ne "") && ( -e $ignore_file)) {
	open (IGNORE, "$ignore_file");
	while (<IGNORE>) {
	    chomp;
	    next if (/\#/);  #skip comments
	    next if (/^\s*$/); # and blank lines
	    if (/\//) {
		push(@ignore_array,$_);
		$array_counter++;
	    } else {
		$ignore_hash{$_} = 1;
		$hash_counter++;
	    }
	}
	close (IGNORE);
	&write_log (4,"Loaded $hash_counter addresses from $ignore_file.");
	&write_log (4,"Loaded $array_counter CIDR netblocks from $ignore_file.");
    }
}

sub build_target_hash {
    my $tmsg = $_[0];
    &write_log (3,$tmsg);
    # This is the target hash. If a packet was destined to any of these, then the
    # sender of that packet will get denied, unless it is on the ignore list.
    %target_hash = ("$network_address" => 1,
		    "$broadcast_address" => 1,
		    "0" => 1,   # This is what gets sent to &checkem if no destination was found.
		    "$host_ip_address" => 1);
    my $counter = 0;
    if (($target_file ne "") && ( -e $target_file)) {
	open (TARG, "$target_file");
	while (<TARG>) {
	    chomp;
	    next if (/\#/);  #skip comments
	    next if (/^\s*$/); # and blank lines
	    $target_hash{$_} = 1;
	    $counter++;
	}
	close (TARG);
	&write_log (4,"Loaded $counter addresses from $target_file.");
    }
}

sub build_manual_hashes {
    my $tmsg = $_[0];
    &write_log (3,$tmsg);
    @CIDR_array = ();
    %ipblock_hash = ();
    # we're scanning the ipblock config file for IPs and CIDR netblocks entered manually.
    # the purpose of these hashes is to be able to check if an attacking IP is manually
    # managed or if it is contained within a manually managed CIDR netblock. this tracking
    # is so that we do NOT create a "Blocked by Guardian" entry for the attacking IP 
    # since it is already manually blocked.
    my $CIDR_counter = 0;
    my $IP_counter = 0;
    if (($ip_block_file_name ne "") && ( -e $ip_block_file_name)) {
	open (BLOCKFILE, "$ip_block_file_name");
	while (<BLOCKFILE>) {
	    chomp;
	    my @temp = split(/\,/);
	    if ($temp[5] eq 'off') {       # if the entry is NOT managed by GAR
		if ($temp[0] =~/\//) {     # if the source address contains a / (ie: 1.1.1.1/24)
		    push(@CIDR_array,$temp[0]);
		    $CIDR_counter++;
		} else {
		    $ipblock_hash{$temp[0]} = 1;
		    $IP_counter++;
		}
	    }
	}
	close (BLOCKFILE);
	&write_log (4,"Loaded $IP_counter manually entered IPs from $ip_block_file_name.");
	&write_log (4,"Loaded $CIDR_counter manually entered CIDR netblocks from $ip_block_file_name.");
    }
    ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks) = stat($ip_block_file_name);
    $prev_ipblock_ctime = $ctime;
}

sub check_hostIP {
    my $oldIP = $host_ip_address;
    my $newIP = &get_host_ip($interface);
    if ($oldIP ne $newIP) {
	&write_log (3,"Our IP address has changed. Updating to new IP.");
	$host_ip_address = $newIP;
	&write_log (0,"IP $host_ip_address assigned on $interface.");
	&build_target_hash ("Rebuilding target hash...");    # rebuild target hash to include our new ip address
    }
}

sub check_unblockfile {
    if ( -s $ip_unblock_file_name ) {   # The size is greater than 0, so pull out IP's and clear file
	# Open file for reading, lock it, read in contents into array, close file
	open (UNBLOCK, "$ip_unblock_file_name") or die "CHECK_UNBLOCKFILE: Unable to open $ip_unblock_file_name for reading.";
	flock UNBLOCK, 2;
	my @current = <UNBLOCK>;
	close (UNBLOCK);
	# Open file for writing, lock it, remove each entry from GAR IF it is in the hash
	open (UNBLOCK, ">$ip_unblock_file_name") or die "CHECK_UNBLOCKFILE: Unable to open $ip_unblock_file_name for updating.";
	flock UNBLOCK, 2;
	my $line;
	foreach $line (@current) {
	    chomp $line;
            next if $line =~ /^iptables/; # skip over iptables text that should not exist in the first place
	    if ($block_hash{$line} eq "") {      # does the entry from the unblock file exist in the hash??
		# no, the entry does not exist in our block hash.
		&write_log (0,"Received notice from GUI : unblock $line : NOT IN HASH");
		# update the manual hashes because the unblock call is for the removal of a manually managed IP or CIDR block.
		&build_manual_hashes ("Rebuilding manual ipblock IPs and CIDR netblocks hashes...");
	    } else {                             # the entry does exist
		&write_log (0,"Received notice from GUI : unblock $line : OK");
		# original call_unblock removes tracker files (2nd param) and skips processing from GUI notice since GUI had already removed the necessary info...
		#&call_unblock ($line, "TRUE", "TRUE");
		# we're not removing the tracker files any more, so second parameter is now FALSE...
		#&call_unblock ($line, "FALSE", "TRUE");
		# new call to call_unblock since switching to GARipblock removes tracker files (2nd param) and must process the iptables rules since the GUI doesn't remove then any more (3rd param)...
		&call_unblock ($line, "TRUE", "FALSE");
	    }
	}
	# Clear file
	truncate (UNBLOCK, 0);
	close (UNBLOCK);
    }
}

sub check_file_changed {
    my $check_file = $_[0];
    if ($check_file eq $alert_file) {            # If we're testing the alert file and
	($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks) = stat($check_file);
	if ($size < $prev_alert_size) {          # the filesize is less than last we checked,
	    &write_log (2,"Alert filename changed. Reopening $alert_file");
	    close (ALERT);                       # we need to close and
	    open (ALERT, "$alert_file");         # reopen it.
	    $prev_alert_size = $size;
	} else {
	    $prev_alert_size = $size;
	}
    }
    if ($check_file eq $opt_c) {                 # If we're testing the config file,
	($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks) = stat($check_file);
	if ($ctime > $prev_conf_ctime) {         # If the creation timestamp is newer then last we checked,
	    &write_log (2,"Config file changed. Reloading configuration options.");
	    $prev_conf_ctime = $ctime;
	    &load_config;
	} else {
	    $prev_conf_ctime = $ctime;
	}
    }
    if ($check_file eq $ignore_file) {           # If we're testing the ignore file,
	($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks) = stat($check_file);
	if ($ctime > $prev_ignore_ctime) {       # If the modified timestamp is newer then last we checked,
	    &write_log (2,"Ignore file changed.");
	    $prev_ignore_ctime = $ctime;
	    &build_ignore_hash ("Rebuilding ignore hash and CIDR array...");
	} else {
	    $prev_ignore_ctime = $ctime;
	}
    }
    if ($check_file eq $target_file) {           # If we're testing the target file,
	($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks) = stat($check_file);
	if ($ctime > $prev_target_ctime) {       # If the modified timestamp is newer then last we checked,
	    &write_log (2,"Target file changed.");
	    $prev_target_ctime = $ctime;
	    &build_target_hash ("Rebuilding target hash...");
	} else {
	    $prev_target_ctime = $ctime;
	}
    }
    if ($check_file eq $ip_block_file_name) {    # If we're testing the ipblock conf file,
	($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks) = stat($check_file);
	if ($ctime > $prev_ipblock_ctime) {      # If the modified timestamp is newer then last we checked,
	    &write_log (2,"GARipblock file changed.");
	    $prev_ipblock_ctime = $ctime;
	    &build_manual_hashes ("Rebuilding manual ipblock IPs hash and CIDR netblocks array...");
	} else {
	    $prev_ipblock_ctime = $ctime;
	}
    }
}

sub checkem {
    my ($source,$dest,$type,$id,$priority) = @_;
    my ($gid,$sid,$rev) = split(/:/,$id);
    my $flag = 0;
    &write_log (9,"entering checkem with $source, $dest, $type, $id, $priority");
    if (index($type,"BLOCKED") > -1) {      # Does $type contain our keyword for special outbound trackers? (ie: failed logins)
	my $xsource = $dest;                # Save destination address
	my $xdest = $source;                # Save source address
	$source = $xsource;                 # Swap source with old destination address
	$dest = $xdest;                     # Swap destination with old source address
    }
    my $statmsg = "'$priority' $source->$dest $type";
    if ($ignore_gids{$gid} == 1) { # check our ignored GIDs list
	&write_log (6,"$statmsg - GID $gid is in GID Ignore list - No action taken.");
	return 1
    }
    if ($ignore_sids{$gid.":".$sid} == 1) { # check our ignored SIDs list
	&write_log (6,"$statmsg - SID $gid:$sid is in SID Ignore list - No action taken.");
	return 1
    }
    if ($source eq $host_ip_address) { # this should prevent us from nuking ourselves
	&write_log (6,"$statmsg - Source = Host - No action taken.");
	return 1
    }
    if (($host_gateway_byte ne "") && ($source eq $gateway_address)) { # this should prevent us from nuking our gateway
	&write_log (6,"$statmsg - Source = Gateway - No action taken.");
	return 1
    }
    if (($priority && $MinPriority) && ($priority < $MinPriority)) { # check if priority is less than minimum.
	&write_log (6,"$statmsg - Priority < MinPriority - No action taken.");
	return 1;
    }
    if (($priority && $MaxPriority) && ($priority > $MaxPriority)) { # check if priority is greater than maximum.
	&write_log (6,"$statmsg - Priority > MaxPriority - No action taken.");
	return 1;
    }
    if (($priority == '') && ($MTPriority eq 'no')) { # check if priority is blank and if we allow blocking on emptys.
	&write_log (6,"$statmsg - Not blocking empty priorities - No action taken.");
	return 1;
    }
    if ($ignore_hash{$source} == 1) { # check our ignored IPs list.
	&write_log (6,"$statmsg - Source in ignore list - No action taken.");
	return 1;
    }
    if (Net::CIDR::cidrlookup($source,@ignore_array)) { # check our ignored IPs CIDR list.
	&write_log (6,"$statmsg - Source exists in an ignore list CIDR netblock - No action taken.");
	return 1;
    }
    if (Net::CIDR::cidrlookup($source,@CIDR_array)) { # check the CIDR list of manually entered ipblock entries.
	&write_log (6,"$statmsg - Source exists in an ipblock CIDR netblock - No action taken.");
	return 1;
    }
    if ($ipblock_hash{$source} == 1) { # check our manual ipblock IPs list.
	&write_log (6,"$statmsg - Source in manual ipblock IPs list - No action taken.");
	return 1;
    }
    # if the offending packet was sent to one of our RED WAN addresses, the network address, or the
    # broadcast address, then block it.
    if ($target_hash{$dest} == 1) {
	&ipchain ($source, $dest, $type, $priority, $statmsg);
    } else {
	# you will see this if the destination was not in the $target_hash, and the packet was not ignored before the
	# target check. the target hash contains all our RED WAN addresses, the network address, and the broadcast address.
	&write_log(2,"$statmsg - Odd, Has Host IP changed? (source = $source, dest = $dest) - No action taken.");
	&check_hostIP;
    }
}

sub create_tracker_file {
    my ($trackedip, $msg) = @_;
    my $ip_tracker_file_name = "$ip_tracker_dir/$trackedip";
    &write_log (4,"Creating $trackedip\'s tracker file");
    &write_log (5,"$trackedip => $msg");
    open (TRACKER, ">$ip_tracker_file_name") or die "CREATE_TRACKER_FILE: Unable to create tracker file $ip_tracker_file_name."; # create tracker file first
    flock TRACKER, 2;
    print TRACKER "$msg\n";
    close (TRACKER);
}

sub update_tracker_file {
    my ($trackedip, $msg) = @_;
    my $ip_tracker_file_name = "$ip_tracker_dir/$trackedip";
    &write_log (4,"Updating $trackedip\'s tracker file");
    &write_log (5,"$trackedip => $msg");
    open (TRACKER, ">>$ip_tracker_file_name") or die "UPDATE_TRACKER_FILE: Unable to open tracker file $ip_tracker_file_name for appending.";
    flock TRACKER, 2;
    print TRACKER "$msg\n";
    close (TRACKER);
}

sub update_ipblock_file {
#    my $msg = @_[0];
    my ($methodtype,$source_ip,$bfmsg) = @_;
    &write_log (9,"entering update_ipblock_file with $methodtype, $source_ip, $bfmsg");
    my $themsg;
    $themsg = substr($bfmsg,0,255);
    if ($methodtype eq "add") {
	&write_log (5,"Adding new entry to ipblock file");
	open (BLOCKFILE, ">>$ip_block_file_name") or die "UPDATE_IPBLOCK(add): Unable to open $ip_block_file_name for addition.";
	flock BLOCKFILE, 2;
	print BLOCKFILE "$themsg\n";
	close (BLOCKFILE);
    } elsif ($methodtype eq "update") {
	&write_log (5,"Updating entry in ipblock file");
	open (BLOCKFILE, "$ip_block_file_name") or die "UPDATE_IPBLOCK(update): Unable to open $ip_block_file_name for reading.";
        my @current = <BLOCKFILE>;
	close (BLOCKFILE);
	my $line;
	open (BLOCKFILE, ">$ip_block_file_name") or die "UPDATE_IPBLOCK(update): Unable to open $ip_block_file_name for updating.";
	flock BLOCKFILE, 2;
	foreach $line (@current) {
	    chomp($line);
	    my @temp = split(/\,/,$line);  # split the line into the fields separated by the commas.
	    if (($temp[0] eq $source_ip) && ($temp[5] eq 'on')) {
		&write_log (9,"found $source_ip managed by GAR in ipblock file");
		&write_log (9,"old line  : $line");
		# source matches and GAR Added flag is 'on', so write the line with the updated comment.
		$line = "$temp[0],$temp[1],$temp[2],$temp[3],$themsg,$temp[5]";
		&write_log (9,"new line  : $line");
	    } else {
		# source does not match and/or GAR Added flag is 'off', so keep existing line.
		&write_log (9,"keep line : $line");
	    }
	    # write the line to block file. this is the existing line or the new one we just built.
	    &write_log (9,"write line: $line");
	    print BLOCKFILE "$line\n";
	}
	close (BLOCKFILE);
    } else {
	&write_log (2,"UPDATE_IPBLOCK_FILE: unknown option '$methodtype'");
    }
    # now make sure we update the the ipblock file's previous ctime variable since _we_ made the update
    ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks) = stat($ip_block_file_name);
    $prev_ipblock_ctime = $ctime;
    &write_log (9,"leaving update_ipblock_file");
}

sub ipchain {
    my ($source, $dest, $type, $priority, $logmsg) = @_;
    &write_log (9,"entering ipchain with $source, $dest, $type, $priority");
    if ($priority == 1) {
	$kicktime = time() + $TLimit1;
    } elsif ($priority == 2) {
	$kicktime = time() + $TLimit2;
    } elsif ($priority == 3) {
	$kicktime = time() + $TLimit3;
    } elsif ($priority == 4) {
	$kicktime = time() + $TLimit4;
    } else {
	$kicktime = time() + $DefTLimit;
    }
    ($wkday,$month,$day,$time,$year) = split(/\s+/, localtime($kicktime));
    $ktimestr = "$day-$month-$year $time";
    ($wkday,$month,$day,$time,$year) = split(/\s+/, localtime);
    $blocktimestr = "$day-$month-$year $time";
    if ($block_hash{$source} eq "") {                     # new entry. add to ipblock and create tracker file with initial entry
	$block_hash{$source} = $kicktime;
	&write_log (0,"$logmsg - Blocked till $ktimestr");
#	&update_ipblock_file ("add", "$source", "$source,off,DROP,on,\<a href=\"javascript:displayGAR_Tracker('$source');\"\>BLOCKED by GAR\</a\> ** $blocktimestr ** $type,on");
	&update_ipblock_file ("add", "$source", "$source,off,DROP,on,\<a href=\"javascript:displayGAR_Tracker('$source');\"\>$blocktimestr\</a\> ** $type,on");
	&write_log (5,"Adding $source\'s GARcheckInbound src rule.");
	system ("/sbin/iptables -A GARcheckInbound -s $source -j GARdrop");
	&write_log (5,"Adding $source\'s GARcheckOutbound dst rule.");
	system ("/sbin/iptables -A GARcheckOutbound -d $source -j GARreject");
# we keep the old tracker files so don't use create since it will truncate them.
# instead, update them which should create them if they do not already exist.
#	&create_tracker_file ($source,"Active: $blocktimestr ** Expire: $ktimestr ** $type");
	&update_tracker_file ($source,"Active: $blocktimestr ** Expire: $ktimestr ** $type");
    } else {
	# We have already blocked this one, but snort detected another attack. So we will
	# update the time blocked. However, we will only update the expire time if it is
	# more in the future than the currently recorded time blocked.
	if ($block_hash{$source} <= $kicktime) {
	    # update the hash with the new expire time
	    $block_hash{$source} = $kicktime;
	    &write_log (3,"$logmsg - Extended till $ktimestr");
#	    &update_ipblock_file ("update", "$source", "\<a href=\"javascript:displayGAR_Tracker('$source');\"\>BLOCKED by GAR\</a\> ** $blocktimestr ** $type");
	    &update_ipblock_file ("update", "$source", "\<a href=\"javascript:displayGAR_Tracker('$source');\"\>$blocktimestr\</a\> ** $type");
	    # if the existing expire time runs out before the newly calculated one
	    &update_tracker_file ($source, "Updated: $blocktimestr ** New Expire: $ktimestr ** $type");
	} else {
	    # we have an entry that would reduce the expire time.
	    # we never reduce the expire time. we only extend it.
	    $kicktime = $block_hash{$source};    # retrieve current expire time to use in the retain update
	    ($wkday,$month,$day,$time,$year) = split(/\s+/, localtime($kicktime));
	    $ktimestr = "$day-$month-$year $time";
	    &write_log (3,"$logmsg - Retained till $ktimestr");
#	    &update_ipblock_file ("update", "$source", "\<a href=\"javascript:displayGAR_Tracker('$source');\"\>BLOCKED by GAR\</a\> ** $blocktimestr ** $type");
	    &update_ipblock_file ("update", "$source", "\<a href=\"javascript:displayGAR_Tracker('$source');\"\>$blocktimestr\</a\> ** $type");
	    &update_tracker_file ($source, "Updated: $blocktimestr ** Retained Expire: $ktimestr ** $type");
	}
    }
    &write_log (9,"leaving ipchain");
}

sub load_saved {
    my $counter = 0;
    &write_log (3,"Loading saved IP records...");
    if ( -e $saved_ip_block_file_name) {
	my $line;
	open (SAVEDFILE, "$saved_ip_block_file_name") or die "LOAD_SAVED: Unable to open $saved_ip_block_file_name for reading.";
	my @current = <SAVEDFILE>;
	close (SAVEDFILE);
	open (BLOCKFILE, ">>$ip_block_file_name") or die "LOAD_SAVED: Unable to open $ip_block_file_name for appending.";
	flock BLOCKFILE, 2;
	foreach $line (@current) {
	    chomp($line);
	    my @temp = split(/\|/,$line);          # split out the two parts of the saved record. 1st part is time stamp. 2nd part is ip portion
	    my @t_line = split(/\,/,$temp[1]);     # split out the parts of the saved ipblock config line
	    if ($block_hash{$t_line[0]} eq "") {   # do we already have an entry for this IP?
		print BLOCKFILE "$temp[1]\n";             # put the saved ipblock config line into the ipblock config file
#		if ($t_line[1] eq 'on') {            # does this entry have forced logging turned on?
#		    system ("/sbin/iptables -A ipblock -s $t_line[0] -j LOG --log-prefix 'GAR-DROP: '");  # add the ip to the LOG table
#		}
		system ("/sbin/iptables -A GARcheckInbound -s $t_line[0] -j GARdrop");  # add the ip to the DROP table
		system ("/sbin/iptables -A GARcheckOutbound -d $t_line[0] -j GARreject");  # add the ip to the DROP table
		$block_hash{$t_line[0]} = $temp[0];  # put the saved expiry for the IP in the block hash
		$counter++;
	    } else {
		&write_log (2,"Skipping duplicate saved entry for $t_line[0].");
	    }
	}
	close (BLOCKFILE);                            # close the file when we're done
	# now make sure we update the the ipblock file's previous ctime variable since _we_ made the update
	($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks) = stat($ip_block_file_name);
	$prev_ipblock_ctime = $ctime;
	unlink $saved_ip_block_file_name;        # delete the saved file since we don't need it any more
    }
    &write_log (4,"Loaded $counter saved IP records...");
}

sub load_config {
 if ($opt_c eq "") {$opt_c = "$modroot/etc/GAR.conf";}
 if (! -e $opt_c) {die "LOAD_CONFIG: Config file $opt_c does not exist!\n";}
 open (CONF, $opt_c) or die "LOAD_CONFIG: Cannot read the config file $opt_c, $!\n";
 while (<CONF>) {
  chomp;
  next if (/^\s*$/); #skip blank lines
  next if (/^#/); # skip comment lines
  if (/^LogFile\s+(.*)/i)         {$logfile = $1;}
  if (/^Interface\s+(.*)/i)       {$interface = $1;}
  if (/^HostIpAddr\s+(.*)/i)      {$host_ip_address = $1;}
  if (/^HostGatewayByte\s+(.*)/i) {$host_gateway_byte = $1;}
  if (/^AlertFile\s+(.*)/i)       {$alert_file = $1;}
  if (/^IgnoreFile\s+(.*)/i)      {$ignore_file = $1;}
  if (/^TargetFile\s+(.*)/i)      {$target_file = $1;}
  if (/^MaxPriority\s+(.*)/i)     {$MaxPriority = $1;}
  if (/^MinPriority\s+(.*)/i)     {$MinPriority = $1;}
  if (/^MTPriority\s+(.*)/i)      {$MTPriority = $1;}
  if (/^ForceLogging\s+(.*)/i)    {$ForceLogging = $1;}
  if (/^LogMsgLevel\s+(.*)/i)     {$logmsglevel = $1;}
  if (/^IgnoreSIDs?\s+(.*)/i) {
     $ignore_sids = $1;
     for $k (split(/\,/,$ignore_sids)) { # split the IgnoreSIDs line on the commas
        $ignore_sids{$k} = 1;
     }
  }
  if (/^IgnoreGIDs?\s+(.*)/i) {
     $ignore_gids = $1;
     for $k (split(/\,/,$ignore_gids)) { # split the IgnoreGIDs line on the commas
        $ignore_gids{$k} = 1;
     }
  }
  if (/^TimeLimit\s+(.*)/i) {$DefTLimit = $1;}
  if (/^Pri1TimeLimit\s+(.*)/i) {$TLimit1 = $1;}
  if (/^Pri2TimeLimit\s+(.*)/i) {$TLimit2 = $1;}
  if (/^Pri3TimeLimit\s+(.*)/i) {$TLimit3 = $1;}
  if (/^Pri4TimeLimit\s+(.*)/i) {$TLimit4 = $1;}
 }
 ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks) = stat($opt_c);
 $prev_conf_ctime = $ctime;
 if (defined $ignore_file) {
  ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks) = stat($ignore_file);
  $prev_ignore_ctime = $ctime;
 }
 if (defined $target_file) {
  ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks) = stat($target_file);
  $prev_target_ctime = $ctime;
 }
 &validate_config;
 &build_ignore_hash ("Building ignore hash and CIDR array...");
 &build_target_hash ("Building target hash...");
 &build_manual_hashes ("Building manual ipblock IPs hash and CIDR netblocks array...");
 &report_config;
}

sub set_other_addresses {
 $network_address = $host_ip_address;
 $network_address =~ s/\d+$/0/;
 if (defined $host_gateway_byte) {
  $gateway_address = $host_ip_address;
  $gateway_address =~ s/\d+$/$host_gateway_byte/;
 }
 $broadcast_address = $host_ip_address;
 $broadcast_address =~ s/\d+$/255/;
}

sub validate_config {
 if ($logfile eq "") {
  print "Warning! LogFile is undefined. Assuming /var/smoothwall/mods/GAR/var/log/GAR.log.\n";
  $logfile = "/var/smoothwall/mods/GAR/var/log/GAR.log";
 }
 if (-e $logfile) {
  if (! -w $logfile) {
    print "VALIDATE_CONFIG: Warning! Logfile is not writeable! Exiting...\n";
    die;
  }
 } else {
  system ('/bin/touch', "$logfile");
 }
 if (!defined $logmsglevel) {
  print "Warning! LogMsgLevel is undefined. Defaulting to level 3.\n";
  $logmsglevel = 3;
 }
 &write_log (0,"----------------------------------------");
 &write_log (0,"$progname $garversion initializing...");
 if ($iptables_up == "no") {
   &write_log (1,"Creating GAR iptables chains");
   system ("$modroot/etc/rc.d/rc.GAR.up");
   $iptables_up = "yes";
 }
 if ($interface eq "") {
  &write_log (1,"Fatal! Interface is undefined. Please define it in $opt_c with keyword 'Interface'.");
  die;
 }
 if (!defined $host_ip_address) {
  &write_log (2,"Warning! HostIpAddr is undefined. Checking $interface...");
  $host_ip_address = &get_host_ip($interface);
  &write_log (0,"IP $host_ip_address assigned on $interface.");
 }
 if ($host_ip_address !~ /\d+\.\d+\.\d+\.\d+/) {
  &write_log (2,"This ip address is bad : $host_ip_address");
  &write_log (1,"I need a good host ip address.");
  die;
 }
 if (($host_gateway_byte eq "") && (index($interface,"ppp") == -1)) {
  &write_log (2,"Warning! HostGatewayByte is undefined. Gateway will not be in ignore list.");
 }
 &set_other_addresses;
 if ($alert_file eq "") {
  &write_log (2,"Warning! AlertFile is undefined. Assuming /var/log/snort/alert");
  $alert_file = "/var/log/snort/alert";
 }
 if ($ignore_file eq "") {
  &write_log (2,"Warning! IgnoreFile is undefined. Using default ignore list of hostip and gateway.");
 }
 if (!defined $MaxPriority) {
  &write_log (2,"Warning! MaxPriority not defined. Defaulting to 4.");
  $MaxPriority = 4;
 }
 if (!defined $MinPriority) {
  &write_log (2,"Warning! MinPriority not defined. Defaulting to 1.");
  $MinPriority = 1;
 }
 if (!defined $MTPriority) {
  &write_log (2,"Warning! MTPriority not defined. Defaulting to 'yes'.");
  $MTPriority = "yes";
 }
 if (!defined $ForceLogging) {
  &write_log (2,"Warning! ForceLogging not defined. Defaulting to 'no'.");
  $ForceLogging = "no";
 }
 if (!defined $DefTLimit) {
  &write_log (2,"Warning! Default time limit not defined. Defaulting to absurdly long time limit.");
  $DefTLimit = 999999999; # 31.5 years!
 }
 if ((!defined $TLimit1) || ($TLimit1 == 0)) {
  &write_log (2,"Warning! Time limit 1 not defined. Using default time limit.");
  $TLimit1 = $DefTLimit;
 }
 if ((!defined $TLimit2) || ($TLimit2 == 0)) {
  &write_log (2,"Warning! Time limit 2 not defined. Using default time limit.");
  $TLimit2 = $DefTLimit;
 }
 if ((!defined $TLimit3) || ($TLimit3 == 0)) {
  &write_log (2,"Warning! Time limit 3 not defined. Using default time limit.");
  $TLimit3 = $DefTLimit;
 }
 if ((!defined $TLimit4) || ($TLimit4 == 0)) {
  &write_log (2,"Warning! Time limit 4 not defined. Using default time limit.");
  $TLimit4 = $DefTLimit;
 }
}

sub report_config {
 &write_log (0,"Logging Message Level $logmsglevel");
 &write_log (7,"Logfile         : $logfile");
 &write_log (7,"Interface       : $interface");
 &write_log (7,"Host IP         : $host_ip_address");
 if (defined $host_gateway_byte) {
  &write_log (7,"Host GW Byte    : $host_gateway_byte");
 }
 &write_log (7,"Network Address : $network_address");
 &write_log (7,"Gateway Address : $gateway_address");
 &write_log (7,"BCast Address   : $broadcast_address");
 &write_log (7,"Alert File      : $alert_file");
 &write_log (7,"Ignore File     : $ignore_file");
 &write_log (7,"Target File     : $target_file");
 &write_log (7,"Max. Priority   : $MaxPriority");
 &write_log (7,"Min. Priority   : $MinPriority");
 &write_log (7,"Empty Priority  : $MTPriority");
 &write_log (7,"Force Logging   : $ForceLogging");
 &write_log (7,"Def Timelimit   : $DefTLimit seconds == ".($DefTLimit/60)." minutes == ".($DefTLimit/3600)." hours == ".($DefTLimit/86400)." days");
 &write_log (7,"Pri 1 Timelimit : $TLimit1 seconds == ".($TLimit1/60)." minutes == ".($TLimit1/3600)." hours == ".($TLimit1/86400)." days");
 &write_log (7,"Pri 2 Timelimit : $TLimit2 seconds == ".($TLimit2/60)." minutes == ".($TLimit2/3600)." hours == ".($TLimit2/86400)." days");
 &write_log (7,"Pri 3 Timelimit : $TLimit3 seconds == ".($TLimit3/60)." minutes == ".($TLimit3/3600)." hours == ".($TLimit3/86400)." days");
 &write_log (7,"Pri 4 Timelimit : $TLimit4 seconds == ".($TLimit4/60)." minutes == ".($TLimit4/3600)." hours == ".($TLimit4/86400)." days");
 &write_log (7,"Ignored GIDs    : $ignore_gids");
 &write_log (7,"Ignored SIDs    : $ignore_sids");
}

sub write_log {
 my $daystr;
 my ($msgreportlevel, $message) = @_;
 if ($msgreportlevel <= $logmsglevel) {
  ($wkday,$month,$day,$time,$year) = split(/\s+/, localtime);
  if ($day <= 9) {
    $daystr = " $day";
  } else {
    $daystr = $day;
  }
  open (LOG, ">>$logfile");
  print LOG "$month $daystr $time $msgsymbols[$msgreportlevel] $message\n";
  close (LOG);
 }
}

sub daemonize {
 my ($home);
 if (fork()) {
  # parent
  exit(0);
 } else {
  # child
  &write_log (0,"Becoming a daemon - process id $$");
  open (GPID, ">>$pid_file");
  print GPID $$;
  close (GPID);
  $home = (getpwuid($>))[7] || die "DAEMONIZE: No home directory!\n";
  chdir($home);                   # go to my homedir
  setpgrp(0,0);                   # become process leader
  close (STDOUT);
  close (STDIN);
  close (STDERR);
 }
}

sub get_host_ip {
    my $interface = $_[0];
    my $ip;
    my $ipnoted = 0;
    while ($ip eq "") {
	open (IFCONFIG, "/sbin/ifconfig $interface |");
	while (<IFCONFIG>) {
	    if (/inet addr:(\d+\.\d+\.\d+\.\d+)/) {
		$ip = $1;
	    }
	    if (index($interface,"ppp") > -1) {
		 if (/P-t-P:(\d+\.\d+\.\d+\.\d+)/) {
		    $gateway_address = $1;
		}
	    }
	}
	close (IFCONFIG);
	if (($ip eq "") && (!$ipnoted)) {
	    &write_log (2,"Waiting for $interface to stabilize.");
	    $ipnoted = 1;
	    sleep 1;
	}
    }
 return $ip;
}

sub expire_blocks {
  my $source;
  my $time = time();
  foreach $source (keys %block_hash) {
    if ($block_hash{$source} < $time) {
      &write_log (0,"Expiring block of $source");
# to delete the tracker files, the second param is TRUE. FALSE to keep them...
      # we're not removing the tracker files any more,
      # so second parameter is now FALSE...
      &call_unblock ($source, "TRUE", "FALSE");
      #&call_unblock ($source, "FALSE", "FALSE");
    }
  }
}

sub call_unblock {
    my ($source, $killtrackfile, $GUI_unblock) = @_;
    my $exitcode = 0;
    my $ip_tracker_file_name = "$ip_tracker_dir/$source";
    my $update_manual_hashes = 0;
    # kill the entry from the block_hash
    #  do this kill first in case the source is no longer
    #  in the ipblock file for some unfathomable reason. this
    #  will prevent GAR from looping over and over trying to
    #  remove a source that exists only in its internal hash.
    &write_log (5,"Removing $source from internal hash");
    delete ($block_hash{$source});
    &write_log (6,"Looking for $source in $ip_block_file_name file");
    if ($GUI_unblock eq "FALSE") {
	&write_log (6,"call_unblock : \$GUI_unblock eq FALSE");
        open (BLOCKFILE, "$ip_block_file_name") or die "CALL_UNBLOCK: Unable to open $ip_block_file_name for reading.";
        my @current = <BLOCKFILE>;
        close (BLOCKFILE);
        my $line;
        open (BLOCKFILE, ">$ip_block_file_name") or die "CALL_UNBLOCK: Unable to open $ip_block_file_name for updating.";
        flock BLOCKFILE, 2;
        foreach $line (@current) {
	    chomp($line);
	    my @temp = split(/\,/,$line);
	    if ($temp[0] eq $source) {
		&write_log (6,"Located ipblock entry for $source");
		if ($temp[5] eq 'on') {      # "GAR Added" flag is 'on' and source matches, so remove entries
		    &write_log (6,"$source is GAR managed");
		    # remove the DROP rule
		    &write_log (5,"Removing $source\'s GARcheckInbound src rule");
		    system ("/sbin/iptables -D GARcheckInbound -s $source -j GARdrop");
		    &write_log (6,"Result code : $?");
		    if ($? == -1) {
			&write_log (6,"system iptables command #1 failed : '$!'");
		    } elsif ($? & 127) {
			$exitcode = ($? & 127);
			&write_log (6,"Removing $source\'s GARcheckInbound src rule : DIED - signal $exitcode");
		    } elsif (($? >> 8) > 0) {
			$exitcode = ($? >> 8);
			&write_log (6,"Removing $source\'s GARcheckInbound src rule : FAILED - exitcode $exitcode");
		    } else {
			&write_log (6,"Removing $source\'s GARcheckInbound src rule : Success!");
		    }
		    &write_log (5,"Removing $source\'s GARcheckOutbound dst rule");
		    system ("/sbin/iptables -D GARcheckOutbound -d $source -j GARreject");
		    &write_log (6,"Result code : $?");
		    if ($? == -1) {
			&write_log (6,"system iptables command #1 failed : '$!'");
		    } elsif ($? & 127) {
			$exitcode = ($? & 127);
			&write_log (6,"Removing $source\'s GARcheckOutbound dst rule : DIED - signal $exitcode");
		    } elsif (($? >> 8) > 0) {
			$exitcode = ($? >> 8);
			&write_log (6,"Removing $source\'s GARcheckOutbound dst rule : FAILED - exitcode $exitcode");
		    } else {
			&write_log (6,"Removing $source\'s GARcheckOutbound dst rule : Success!");
		    }
#		    if ($temp[1] eq 'on') {  # Forced Logging flag is on so remove the LOG rule from ipblock table
#			&write_log (6,"$source\'s forced logging flag is ON");
#			&write_log (5,"Removing $source\'s ipblock LOG rule");
#			system ("/sbin/iptables -D ipblock -s $source -j LOG --log-prefix 'GAR-DROP: '");
#			if ($? == -1) {
#			    &write_log (6,"system iptables command #2 failed : '$!'");
#			} elsif ($? & 127) {
#			    $exitcode = ($? & 127);
#			    &write_log (6,"Removing $source\'s ipblock LOG rule : DIED - signal $exitcode");
#			} elsif (($? >> 8) > 0) {
#			    $exitcode = ($? >> 8);
#			    &write_log (6,"Removing $source\'s ipblock LOG rule : FAILED - exitcode $exitcode");
#			    &write_log (6,"Retrying removal of $source\'s ipblock LOG rule without --log-prefix");
#			    system ("/sbin/iptables -D ipblock -s $source -j LOG");
#			    if ($? == -1) {
#			        &write_log (6,"Retrying removal of $source\'s ipblock LOG rule without --log-prefix : FAILED - '$!'");
#			    } else {
#			        &write_log (6,"Retrying removal of $source\'s ipblock LOG rule without --log-prefix : Success!");
#			    }
#			} else {
#			    &write_log (6,"Removing $source\'s ipblock LOG rule : Success!");
#			}
#		    } else {
#			&write_log (6,"$source\'s forced logging flag is OFF");
#		    }
		    if ($killtrackfile eq "TRUE") {        # should we delete the tracking file?  TRUE: normal operation, FALSE: shutdown
			&write_log (5,"Removing $source\'s tracker file");
			if (-e $ip_tracker_file_name) {    # does the tracking file exist?
			    unlink $ip_tracker_file_name;
			} else {
			    &write_log (2,"$source\'s tracker file does not exist??");
			}
		    } else {
			&write_log (5,"Keeping $source\'s tracker file");
		    }
		} else {					# GAR Added flag is off... what??
		    &write_log (2,"$source is NOT GAR managed???");
		}
	    } else {
    		# Put the line back in the ipblock file since it does not match the source IP
                next if $line =~ /^iptables/; # skip over iptables text that should not exist in the first place
		&write_log (6,"placing \"$line\" back in $ip_block_file_name");
    		print BLOCKFILE "$line\n";
	    }
	}
	close (BLOCKFILE);
	# now make sure we update the the ipblock file's previous ctime variable since have just rewritten the data
	($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks) = stat($ip_block_file_name);
	$prev_ipblock_ctime = $ctime;
    } else {
	# the ipblock GUI page has indicated change in a GAR managed rule and requested
	# its removal from our internal block hash and then kill its associated trackerfile.
	# we also need to rebuild the manual hashes in case the change was to switch the IP
	# address to manually managed so we can keep up with what is not managed by us.
#	&write_log (6,"call_unblock : \$GUI_unblock eq TRUE");
	&write_log (5,"Removing $source from internal hash");
	delete ($block_hash{$source});
	if ($killtrackfile eq "TRUE") {          # should we delete the tracking file?  TRUE: normal operation, FALSE: shutdown
	    &write_log (5,"Removing $source\'s tracker file");
	    if (-e $ip_tracker_file_name) {    # does the tracking file exist?
		unlink $ip_tracker_file_name;
	    } else {
		&write_log (2,"$source\'s tracker file does not exist.");
	    }
	} else {
	    &write_log (5,"Keeping $source\'s tracker file");
	}
	&build_manual_hashes ("Rebuilding manual ipblock IPs hash and CIDR netblocks array...");
    }
}

sub sig_handler_setup {
    &write_log (4,"Setting up signal handlers.");
    $SIG{TERM} = \&clean_up_and_exit; # kill or kill -15
    $SIG{KILL} = \&clean_up_and_exit; # kill -9
    $SIG{QUIT} = \&clean_up_and_exit; # kill -3
    $SIG{HUP} = \&clean_up_and_exit; # kill -1
}

sub check_extra_trackers {
    # let's hunt down extraneous tracker files possibly left behind when entries were
    # modified in the GUI page. do this before cleaning out the active block hash so we
    # have something to compare with.
    opendir(DIR, $ip_tracker_dir) || die "CHECK_EXTRA_TRACKERS: Can't opendir $ip_tracker_dir: $!";
    @trackers = grep { /^\d+\.\d+\.\d+\.\d+$/ && -f "$ip_tracker_dir/$_" } readdir(DIR);
    closedir DIR;
    my $trackers_file_count = scalar @trackers;
    if ($trackers_file_count > 0) {
	&write_log (3,"Searching for extraneous tracker files...");
        foreach $file (@trackers) {
	    $match = 0;
	    foreach $source (keys %block_hash) {
		if ($file eq $source) {
		    $match = 1;
		}
	    }
	    if (!$match) {   # the trackerfile's name does not exist in the block hash
		$ip_tracker_file = "$ip_tracker_dir/$file";
		&write_log (3,"Removing extraneous tracker file: $ip_tracker_file");
    		unlink $ip_tracker_file;
	    }
	}
	&write_log (3,"Search complete...");
    } else {
        &write_log (0,"No tracker files to search through...");
    }
}

sub clean_up_and_exit {
    &write_log (0,"Received kill signal. Shutting down...");
    my $source;
    my $hash_source;
    my $block_hash_count = scalar keys %block_hash;
    if ($block_hash_count) {
	&write_log (0,"Saving current blocked IP records...");
	open (IPBLOCK_FILE, "$ip_block_file_name") or die "CLEAN_UP_AND_EXIT: Unable to open $ip_block_file_name for reading.";
	my @current = <IPBLOCK_FILE>;
	close (IPBLOCK_FILE);
	my $line;
	open (IPSAVE_FILE, ">$saved_ip_block_file_name") or die "CLEAN_UP_AND_EXIT: Unable to open $saved_ip_block_file_name for writing.";
	flock IPSAVE_FILE, 2;
	my $total = @current;
	&write_log (3,"Working with $total blocked IP records...");
	my $counter = 0;
	foreach $line (@current) {
	    chomp($line);
	    my @temp = split(/\,/,$line);
	    if ($temp[5] eq 'on') {                           # "GAR Added" flag is 'on'
		foreach $hash_source (keys %block_hash) {     # loop thru the hash entries looking for the IP
		    if ($hash_source eq $temp[0]) {           # found the hash entry for the current blocked IP
			my $expiry = $block_hash{$temp[0]};   # get the expiry date and time from the hash entry
			print IPSAVE_FILE "$expiry\|$line\n";        # write expiry and existing ipblock config line to save file
			$counter++;
		    }
		}
	    }
	}
	close (IPSAVE_FILE);
	&write_log (0,"Saved $counter blocked IP records...");
	if ($counter == 0) {
	    unlink $saved_ip_block_file_name;
	}
        &check_extra_trackers;
	# now unblock each entry for shutdown...
	&write_log (3,"Unblocking and removing IPs...");
	foreach $source (keys %block_hash) {
	    &write_log (6,"Calling call_unblock with $source FALSE FALSE");
	    &call_unblock ($source, "FALSE", "FALSE");
	    &write_log (6,"Returned from call_unblock");
	}
	&write_log (3,"Unblocking and removal complete...");
    } else {
        &write_log (0,"No IPs recorded as blocked...");
        &check_extra_trackers;
    }
    close (ALERT);                       # since we keep it open during operation.
    if ($iptables_up == "yes") {
      &write_log (1,"Waiting 5 for iptables to settle");
      sleep 5;
      &write_log (1,"Removing GAR iptables chains");
      system ("$modroot/etc/rc.d/rc.GAR.down");
      &write_log (1,"Waiting 5 for iptables to settle");
      sleep 5;
      $iptables_up = "no";
    }
#    &write_log (5,"Removing unblock file: $ip_unblock_file_name");
#    unlink $ip_unblock_file_name;        # delete the unblock file. it will be recreated at next startup
#    &write_log (3,"Reloading ipblock table");
#    system ('/usr/bin/smoothcom', 'setipblock');
    &write_log (5,"Removing pid file: $pid_file");
    unlink $pid_file;                    # delete our PID file
    &write_log (0,"Shutdown complete.");
    exit;                                # get out of Dodge City!
}
